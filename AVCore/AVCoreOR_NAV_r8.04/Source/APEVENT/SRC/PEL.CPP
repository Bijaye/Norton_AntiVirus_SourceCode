// Copyright 1994 - 1998 Symantec, Peter Norton Product Group
//***************************************************************************
//
// Description:
//      This file defines functions for process exclusion.  The process
//      exclusion list is used by NAVAP to mark processes and threads which
//      are protected.  Events generated by protected processes and threads
//      will be ignored.
//
// Contains:
//      PEL_LockThreadDataPtr()           (local macro)
//      PEL_UnLockThreadDataPtr()         (local macro)
//
//      PELGetCurrentProcessID()          (local macro)
//
//      PELInit()
//      PELDeInit()
//
//      AddCurrentThreadToPEL1()
//      ForceCurrentThreadIntoPEL1()
//      IsCurrentThreadInPEL1()
//      DeleteCurrentThreadFromPEL1()
//
//      AddCurrentProcessToPEL2()
//      GetCurrentProcessPEL2Count()
//      DeleteCurrentProcessFromPEL2()
//
// See Also:
//      pel.h
//
// Note:
//      Event manager module
//
//***************************************************************************

#include "platform.h"
#include "drvcomm.h"
#include "navap.h"
#include "navapel.h"
#include "pel.h"

#if defined(SYM_VXD)
extern "C" void __cdecl THISMAKESMESICK_Get_DDB();
#endif

// Links to the NAVAPEL driver, where the functionality of this module resides.

static fnAddCurrentThreadToPEL1       pAddCurrentThreadToPEL1 = NULL;
static fnForceCurrentThreadIntoPEL1   pForceCurrentThreadIntoPEL1 = NULL;
static fnIsCurrentThreadInPEL1        pIsCurrentThreadInPEL1 = NULL;
static fnDeleteCurrentThreadFromPEL1  pDeleteCurrentThreadFromPEL1 = NULL;
static fnAddCurrentProcessToPEL2      pAddCurrentProcessToPEL2 = NULL;
static fnGetCurrentProcessPEL2Count   pGetCurrentProcessPEL2Count = NULL;
static fnDeleteCurrentProcessFromPEL2 pDeleteCurrentProcessFromPEL2 = NULL;

//---------------------------------------------------------------------------
//
// BOOL PELInit (
//      VOID
//      );
//
// This function initializes the PEL module.
//
// Entry:
//      -
//
// Exit:
//      TRUE  if module was initialized and it is ready for use.
//      FALSE if module initialization failed.
//
// Synchronization:
//      This function is non-reentrant and should not be called more than
//      once.
//
//---------------------------------------------------------------------------
#define DRIVER_INIT_CODE_SEGMENT
#include "drvseg.h"

BOOL PELInit (
    VOID
    )
    {
    auto fnQueryNAVAPELInterface pfnQueryInterface = NULL;

#if defined(SYM_NTK)

    static WCHAR          szDriver[] = L"\\Device\\NAVAPEL";
    auto   UNICODE_STRING ObjectName;
    auto   PFILE_OBJECT   FileObject = NULL;
    auto   PDEVICE_OBJECT DeviceObject = NULL;

    RtlInitUnicodeString ( &ObjectName, szDriver );

    if ( NT_SUCCESS ( IoGetDeviceObjectPointer ( &ObjectName,
                                                 FILE_ALL_ACCESS,
                                                 &FileObject,
                                                 &DeviceObject ) ) )
        {
        auto KEVENT          event;
        auto IO_STATUS_BLOCK IoStatusBlock;
        auto PIRP            Irp = IoBuildDeviceIoControlRequest ( DIOCTL_SYM_USER01,
                                                                   DeviceObject,
                                                                   NULL,
                                                                   0,
                                                                   &pfnQueryInterface,
                                                                   sizeof(pfnQueryInterface),
                                                                   FALSE,
                                                                   &event,
                                                                   &IoStatusBlock );

        if ( Irp )
            {
            KeInitializeEvent ( &event, NotificationEvent, FALSE );

            switch ( IoCallDriver ( DeviceObject, Irp ) )
                {
                case STATUS_PENDING:

                    KeWaitForSingleObject ( &event, Suspended, KernelMode, FALSE, NULL );

                    if ( !NT_SUCCESS ( IoStatusBlock.Status ) )
                        pfnQueryInterface = NULL;

                    break;

                case STATUS_SUCCESS:

                    if ( !NT_SUCCESS ( IoStatusBlock.Status ) ||
                         IoStatusBlock.Information != sizeof(pfnQueryInterface) )
                        pfnQueryInterface = NULL;

                    break;

                default:

                    pfnQueryInterface = NULL;
                }
            }
        }

    if ( FileObject )
        ObDereferenceObject ( FileObject );

#elif defined(SYM_VXD)

    static CHAR           szDriver[] = "NAVAPEL ";
    auto   VxD_Desc_Block *pDDB;

    __asm mov  eax,0
    __asm lea  edi,[szDriver]
    __asm call THISMAKESMESICK_Get_DDB
    __asm mov  pDDB,ecx

    if ( pDDB )
    {
        auto DIOCPARAMETERS rDIOCParms;

        MEMSET ( &rDIOCParms, 0, sizeof(rDIOCParms) );

        rDIOCParms.dwIoControlCode = DIOCTL_SYM_USER01;
        rDIOCParms.lpvOutBuffer    = (DWORD)&pfnQueryInterface;

        __asm lea  esi,[rDIOCParms]
        __asm mov  eax,W32_DEVICEIOCONTROL
        __asm mov  ecx,pDDB
        __asm call [ecx + 18h] // VxD_Desc_Block.DDB_Control_Proc makes me sick too!!!
    }

#endif

    // If we have an interface function, then ask it to fill out a table with function pointers.

    if ( pfnQueryInterface )
        {
        auto NAVAPEL_INTERFACE rInterface;

        rInterface.dwRev = 1;

        if ( pfnQueryInterface ( &rInterface ) && rInterface.dwRev == 0 )
            {
            pAddCurrentThreadToPEL1       = rInterface.pAddCurrentThreadToPEL1;
            pForceCurrentThreadIntoPEL1   = rInterface.pForceCurrentThreadIntoPEL1;
            pIsCurrentThreadInPEL1        = rInterface.pIsCurrentThreadInPEL1;
            pDeleteCurrentThreadFromPEL1  = rInterface.pDeleteCurrentThreadFromPEL1;
            pAddCurrentProcessToPEL2      = rInterface.pAddCurrentProcessToPEL2;
            pGetCurrentProcessPEL2Count   = rInterface.pGetCurrentProcessPEL2Count;
            pDeleteCurrentProcessFromPEL2 = rInterface.pDeleteCurrentProcessFromPEL2;

            return ( TRUE );
            }
        }

    return ( FALSE );
    }

#define DRIVER_DEFAULT_CODE_SEGMENT
#include "drvseg.h"

//---------------------------------------------------------------------------
//
// BOOL PELDeInit (
//      VOID
//      );
//
// This function uninitializes PEL.  No calls to other APIs should be made
// during and after the call to this function.
//
// Entry:
//      -
//
// Exit:
//      Always TRUE
//
// Synchronization:
//      This function is non-reentrant and should not be called more than
//      once.
//
//---------------------------------------------------------------------------
BOOL PELDeInit (
    VOID
    )
    {
    // Reset all APIs, because they should not be called any more.

    pAddCurrentThreadToPEL1 = NULL;
    pForceCurrentThreadIntoPEL1 = NULL;
    pIsCurrentThreadInPEL1 = NULL;
    pDeleteCurrentThreadFromPEL1 = NULL;
    pAddCurrentProcessToPEL2 = NULL;
    pGetCurrentProcessPEL2Count = NULL;
    pDeleteCurrentProcessFromPEL2 = NULL;

    return ( TRUE );
    }

//---------------------------------------------------------------------------
//
// BOOL AddCurrentThreadToPEL1 (
//      VOID
//      );
//
// This function adds the current thread to PEL1.  It does so only if this
// thread not already in PEL.
//
// AddCurrentThreadToPEL1() can be called only after a successful call to
// PELInit(), and before PELDeInit() is called.
//
// Entry:
//      -
//
// Exit:
//      TRUE  if thread was added to PEL1.  Once this function returns
//            TRUE, the per-thread data for the current thread will be
//            locked, and a call to DeleteCurrentThreadFromPEL1() must
//            be issued in order for it to be unlocked.
//      FALSE if thread was not added to PEL1
//
// Synchronization:
//      AddCurrentThreadToPEL1() is fully reentrant for different threads,
//      but cannot be reentered under the context of the same thread.
//
//---------------------------------------------------------------------------
BOOL AddCurrentThreadToPEL1 (
    VOID
    )
    {
    return pAddCurrentThreadToPEL1();
    }

//---------------------------------------------------------------------------
//
// BOOL ForceCurrentThreadIntoPEL1 (
//      VOID
//      );
//
// This function adds the current thread to PEL1 if it is not in PEL1.  The
// status of the current thread/process in PEL2 is ignored.
//
// ForceCurrentThreadIntoPEL1() can be called only after a successful call
// to PELInit(), and before PELDeInit() is called.
//
// Entry:
//      -
//
// Exit:
//      TRUE  if thread was added to PEL1.  Once this function returns
//            TRUE, the per-thread data for the current thread will be
//            locked, and a call to DeleteCurrentThreadFromPEL1() must
//            be issued in order for it to be unlocked.
//      FALSE if thread was not added to PEL1
//
// Synchronization:
//      ForceCurrentThreadIntoPEL1() is fully reentrant for different
//      threads, but cannot be reentered under the context of the same
//      thread.
//
//---------------------------------------------------------------------------
BOOL ForceCurrentThreadIntoPEL1 (
    VOID
    )
    {
    return pForceCurrentThreadIntoPEL1();
    }

//---------------------------------------------------------------------------
//
// BOOL IsCurrentThreadInPEL1 (
//      VOID
//      );
//
// This function checks if the current thread is in PEL1.
//
// IsCurrentThreadInPEL1() can be called only after a successful call to
// PELInit(), and before PELDeInit() is called.
//
// Entry:
//      -
//
// Exit:
//      TRUE  if the current thread is in PEL1
//      FALSE if the current thread is not in PEL1, or if an error occurred
//            while processing.
//
// Synchronization:
//      IsCurrentThreadInPEL1() is fully reentrant for different threads,
//      but cannot be reentered under the context of the same thread.
//
//---------------------------------------------------------------------------
BOOL IsCurrentThreadInPEL1 (
    VOID
    )
    {
    return pIsCurrentThreadInPEL1();
    }

//---------------------------------------------------------------------------
//
// VOID DeleteCurrentThreadFromPEL1 (
//      VOID
//      );
//
// This function deletes the current thread from PEL1.  It should be called
// only after a successful call to AddCurrentThreadToPEL1() from the same
// thread.
//
// DeleteCurrentThreadFromPEL1() can be called only after a successful call
// to PELInit(), and before PELDeInit() is called.
//
// Entry:
//      -
//
// Exit:
//      The current thread was deleted from PEL1, if it was in it.
//
// Synchronization:
//      DeleteCurrentThreadFromPEL1() is fully reentrant for different
//      threads, but cannot be reentered under the context of the same
//      thread.
//
//---------------------------------------------------------------------------
VOID DeleteCurrentThreadFromPEL1 (
    VOID
    )
    {
    pDeleteCurrentThreadFromPEL1();
    }

//---------------------------------------------------------------------------
//
// BOOL AddCurrentProcessToPEL2 (
//      VOID
//      );
//
// This function adds the current process to PEL2.
//
// AddCurrentProcessToPEL2() can be called only after a successful call
// to PELInit(), and before PELDeInit() is called.
//
// Entry:
//      -
//
// Exit:
//      TRUE  if current process was added to the exclusion list
//      FALSE if current process was not added to the exclusion list due
//            to an error
//
// Synchronization:
//      AddCurrentProcessToPEL2() is fully reentrant.
//
//---------------------------------------------------------------------------
BOOL AddCurrentProcessToPEL2 (
    VOID
    )
    {
    return pAddCurrentProcessToPEL2();
    }

//---------------------------------------------------------------------------
//
// int GetCurrentProcessPEL2Count (
//      VOID
//      );
//
// Returns the number of times the current process has been added to PEL2.
//
// GetCurrentProcessPEL2Count() can be called only after a successful call
// to PELInit(), and before PELDeInit() is called.
//
// Entry:
//      -
//
// Exit:
//      Returns current process exclusion count in PEL2.
//
// Synchronization:
//      GetCurrentProcessPEL2Count() is fully reentrant.
//
//---------------------------------------------------------------------------
int GetCurrentProcessPEL2Count (
    VOID
    )
    {
    return pGetCurrentProcessPEL2Count();
    }

//---------------------------------------------------------------------------
//
// VOID DeleteCurrentProcessFromPEL2 (
//      VOID
//      );
//
// This function deletes the current process from PEL2.  Call this function
// once for every successful AddCurrentProcessToPEL2().
//
// DeleteCurrentProcessFromPEL2() can be called only after a successful call
// to PELInit(), and before PELDeInit() is called.
//
// Entry:
//      -
//
// Exit:
//      -
//          Current process deleted from PEL2.  If a mismatch in the number
//          of Add/Delete calls is encountered, this function will display
//          an assertion error in debug compiles.
//
// Synchronization:
//      DeleteCurrentProcessFromPEL2() is fully reentrant.
//
//---------------------------------------------------------------------------
VOID DeleteCurrentProcessFromPEL2 (
    VOID
    )
    {
    pDeleteCurrentProcessFromPEL2();
    }