// Copyright 1995 Symantec, Peter Norton Product Group
//************************************************************************
//
// $Header:   S:\emulator\vcs\opcodele.cpv   1.5   19 Oct 1995 18:23:36   CNACHEN  $
//
// Description:
//
//  This file contains a routine which is used to skip over unknown opcodes
//  which have not been added to the PAM system.  It understands the sizes of
//  all 8086 opcodes.  Does not work for 286+.
//
// Contains:
//
// See Also:
//************************************************************************
// $Log:   S:\emulator\vcs\opcodele.cpv  $
// 
//    Rev 1.5   19 Oct 1995 18:23:36   CNACHEN
// Initial revision... with comment header :)
// 
//************************************************************************


static unsigned char one[256] = {
0x00, 0x00, 0x00, 0x00, 0xfe, 0xfd, 0xff, 0xff,
0x00, 0x00, 0x00, 0x00, 0xfe, 0xfd, 0xff, 0xff,
0x00, 0x00, 0x00, 0x00, 0xfe, 0xfd, 0xff, 0xff,
0x00, 0x00, 0x00, 0x00, 0xfe, 0xfd, 0xff, 0xff,
0x00, 0x00, 0x00, 0x00, 0xfe, 0xfd, 0xff, 0xff,
0x00, 0x00, 0x00, 0x00, 0xfe, 0xfd, 0xff, 0xff,
0x00, 0x00, 0x00, 0x00, 0xfe, 0xfd, 0xff, 0xff,
0x00, 0x00, 0x00, 0x00, 0xfe, 0xfd, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
0x01, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff,
0xfd, 0xfd, 0xfd, 0xfd, 0xff, 0xff, 0xff, 0xff,
0xfe, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd,
0xff, 0xff, 0xfd, 0xff, 0x00, 0x00, 0x01, 0x02,
0xff, 0xff, 0xfd, 0xff, 0xff, 0xfe, 0xff, 0xff,
0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xff, 0xff,
0x00, 0x03, 0x00, 0x04, 0x00, 0x05, 0x00, 0x03,
0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
0xfd, 0xfd, 0xfb, 0xfe, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x07,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00
};

static unsigned char table[8][16] = {
{0x88,0x88,0x88,0x88,0x33,0x33,0x33,0x33,0x44,0x44,0x44,0x44,0x22,0x22,0x22,0x22},
{0x99,0x99,0x99,0x99,0x44,0x44,0x44,0x44,0x55,0x55,0x55,0x55,0x33,0x33,0x33,0x33},
{0xAA,0xAA,0xAA,0xAA,0x55,0x55,0x55,0x55,0x66,0x66,0x66,0x66,0x44,0x44,0x44,0x44},
{0x8C,0x88,0x88,0x88,0x34,0x33,0x33,0x33,0x46,0x44,0x44,0x44,0x22,0x22,0x22,0x22},
{0x8C,0x88,0xC8,0xC8,0x34,0x33,0x43,0x43,0x46,0x44,0x64,0x64,0x22,0x22,0x22,0x22},
{0x8C,0x88,0x8C,0x88,0x34,0x33,0x34,0x33,0x46,0x44,0x46,0x44,0x22,0x22,0x22,0x22},
{0x98,0x88,0x88,0x88,0x43,0x33,0x33,0x33,0x54,0x44,0x44,0x44,0x32,0x22,0x22,0x22},
{0xA8,0x88,0x88,0x88,0x53,0x33,0x33,0x33,0x64,0x44,0x44,0x44,0x42,0x22,0x22,0x22}
};

#define high(n) (!((n >> 3) & 1))

int ret_table(int i,int j);

int ret_table(int i,int j)
{
	int	col, rowval;

	col = j >> 4;
	if (high(j))
		rowval = (table[i][col] >> 4) & 0xf;
	else
		rowval = table[i][col] & 0xf;
	if (rowval & 8) {
		if ((j & 7) == 6) {
			if (rowval == 0xC) return 6;
			return (rowval&3) + 4;
		}
		return (rowval&3) + 2;
	}
	return rowval;
}

int opcodelen(char *buffer)
{
	unsigned char firstbyte;

	firstbyte = (unsigned char)buffer[0];
    if ((signed char)one[firstbyte] < 0)
		return (0-one[firstbyte]);
	return(ret_table(one[firstbyte],buffer[1] & 0xff));
}
