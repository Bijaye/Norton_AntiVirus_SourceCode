// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__701D3E92_DFB3_475F_8165_E21917914BFA__INCLUDED_)
#define AFX_STDAFX_H__701D3E92_DFB3_475F_8165_E21917914BFA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

// Disable identifier truncation warning generated by
// standard C++ library stuff.
#pragma warning( disable: 4786 )

// Debug ATL stuff.
// #define _ATL_DEBUG_QI
// #define ATL_DEBUG_INTERFACES

//
// Standard C++ library stuff
//
#include <string>
#include <map>
#include <queue>

#include <atlbase.h>
#include <atlstr.h>
#include <atltime.h>
#include <process.h>
#include <crtdbg.h>
#ifdef _DEBUG
   #define _CRTDBG_MAP_ALLOC // include Microsoft memory leak detection procedures
   #define _INC_MALLOC     // exclude standard memory alloc procedures
#endif

// Project includes
#include "handlers.h"
#include "serviceconfig.h"

// Core headers.
#include "platform.h"
#include "defutils.h"
#include "AutoProtectWrapper.h"

// ccLib header
#include "ccLib.h"
#include "ccThread.h"
#include "ccSingleLock.h"
#include "ccMessageLock.h"
#include "ccCriticalSection.h"

// Forward declartions 
struct INAVAPEventHandler;
class CNotificationQueue;
class CDefsManager;
class CDefinitionsMonitor;
class COptionsMonitorThread;
class CScanQueue;
class CAPThreatExclusions;

struct LastPacket
{
    CTime time;
    std::wstring wsFile;
    DWORD dwVID;
    DWORD dwActions[3];
};

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CServiceModule : public CComModule
{
public:
	CServiceModule();
	virtual ~CServiceModule();
	HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
	HRESULT UnregisterServer();
	void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid = NULL);
    void Start();
	void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
	LONG Unlock();
	void LogEvent(LPCSTR pszFormat, ...);

    void SetServiceStatus(DWORD dwState, DWORD dwWaitHint = 0 );
    void SetupAsLocalServer();

	// Handler manipulation routines.
	void InsertHandler(INAVAPEventHandler* pHandler);
	void RemoveHandler(INAVAPEventHandler* pHandler);

    // Definition authentication failure routine to notify the agents
    void defAuthenticationFailure(DWORD dwFailure);

	// Reload routines.
	bool ReloadAP(bool bForceReloadAVAPI = false);
	bool ReloadOptions();

	// NAVAP driver status.
	void EnableAP( bool bEnable );
	bool IsAPEnabled();

    bool CreateScanQueue();

    HRESULT WaitForStartup();
    HRESULT CancelScan(VARIANT& vCancelData );
	
    HRESULT ManualScanSpywareDetection(VARIANT& vSpywareItemData);
	
	CServiceConfig& Config();
    CAPThreatExclusions* GetThreatExclusions();
    void SetExclusionsDirty ();
    void StopUsingExclusions ();

	// Misc routines.
	std::string GetAppDir();

	void DoStartupScan();

    CAutoProtectWrapper*    pAPWrapper;

//Implementation
private:
	static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

	static void driverCallback( DWORD dwServiceCode, PVOID pvInBuffer,
								 DWORD dwInBufferSize, PVOID pvOutBuffer,
								 DWORD dwOutBufferSize, PDWORD pdwBytesReturned );
	
	void serviceCallback( DWORD dwServiceCode, PVOID pvInBuffer, DWORD dwInBufferSize );
	void handleProgressEvent( PCSAVRT_EVENTREPORTPACKET pEvent, DWORD dwInBufferSize );
    void handleContainerReportEvent( PSAVRT_CONTAINERREPORTPACKET pEvent, DWORD dwInBufferSize );
    void handleSemiSyncNotificationEvent( PSAVRT_SEMISYNCSCANNOTIFICATIONPACKET pEvent, DWORD dwInBufferSize );
	void handleScanMountEvent( PSAVRT_SCANMOUNTEDDEVICEPACKET pEvent, DWORD dwInBufferSize );

	// Initialization
	bool setupNAVService();
	void shutdownNAVService();

	void startAPDrivers();
	void stopAPDrivers();

	void setupVirusDefs();

	void connectWithAPDriver();
	void disconnectWithAPDriver();

	void doMessagePump();

	void startupNotify();

// public data members
public:
    char m_szServiceName[256];
	char m_szDisplayName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
	DWORD dwThreadID;
	BOOL m_bService;
	bool m_bDebug;

    // Flag indicating there are no authentic definitions available
    bool m_bDefsBad;

// private data members
private:
	// Event handlers object.
	CEventHandlers			m_handlers;

	// Notification queue object.
	CNotificationQueue*		m_pNotificationQueue;

		// Critical section for Driver communications object.
    ccLib::CCriticalSection m_csApDrvComm;

    // Boot record scanning queue object
	CScanQueue*				m_pScanQueue;

	// Definitions monitor object
	CDefinitionsMonitor*	m_pDefMon;

	// Critical section for ReloadAP routine
	ccLib::CCriticalSection m_csReload;

	// Configuration object.
	CServiceConfig			m_config;

	// Options monitor thread
	COptionsMonitorThread*	m_pOptionsMonitorThread;

    std::auto_ptr<CAPThreatExclusions>    m_pAPThreatExclusions;
    bool                    m_bExclusionsDirty;

	// Handle to startup event object.
	HANDLE					m_hStartup;
    ccLib::CEvent           m_hShutdown;

    LastPacket m_LastEvent;
    LastPacket m_LastBootRepairFailure;
};

extern CServiceModule _Module;
extern HINSTANCE      g_hInstance;  // So we can share the CNotification object.
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__701D3E92_DFB3_475F_8165_E21917914BFA__INCLUDED)
