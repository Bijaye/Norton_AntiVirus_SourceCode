// DecIO.cpp : Decomposer IO interface support
// PROPRIETARY/CONFIDENTIAL. Use of this product is subject to license terms.
// Copyright 2000, 2005 by Symantec Corporation.  All rights reserved.

/////////////////////////////////////////////////////////////////////////////
// Headers

// Fix the defect in IBM's header files for V3.x of Visual Age for C++.
#include "fixibmps.h"

// Project headers
#define DEC2_CPP
#include "DecPlat.h"
#include "Dec2.h"
#include "Dec2EX.h"
#include "Dec2LIB.h"
#include "Decstdio.h"
#include "DecIO.h"
#include "dectmpf.h"

#if !defined(_WINDOWS)
	#include <stdarg.h>
#endif

#include "SymSaferStrings.h"

// This is the Decomposer's default CDecIO object.  If the client does not
// specify an IO callback class, then we use this one.
CDecIO g_DecIO;

// All I/O requests generated by the Decomposer will pass through this one object.
CDecIO *g_pDecIO;


void DecSetIOCallback(IDecIOCB *pIOCallback)
{
	// If NULL pointer is passed, use our default CDecIO implementation.
	if (pIOCallback == NULL)
		pIOCallback = &g_DecIO;

#if defined(_WINDOWS)
	g_pDecIO = static_cast<CDecIO *>(pIOCallback);
#else
	g_pDecIO = (CDecIO *)(pIOCallback);
#endif
}

//
// If BYPASS_DECSDK is defined, then we need to bypass these
// implementations of dec_xxx functions. They are redefined
// to route into the C runtime equivalents inside of
// Decstdio.h.
//
#if !defined(BYPASS_DECSDK)

int		dec_access(const char *path, int mode)
{
	return (g_pDecIO->Dec_access(path, mode));
}


int		dec_chmod(const char *filename, int pmode)
{
	return (g_pDecIO->Dec_chmod(filename, pmode));
}


void	dec_clearerr(FILE *stream)
{
	g_pDecIO->Dec_clearerr(stream);
	return;
}


int		dec_fclose(FILE *stream)
{
	return (g_pDecIO->Dec_fclose(stream));
}


int		dec_feof(FILE *stream)
{
	return (g_pDecIO->Dec_feof(stream));
}


int		dec_ferror(FILE *stream)
{
	return (g_pDecIO->Dec_ferror(stream));
}


int		dec_fflush(FILE *stream)
{
	return (g_pDecIO->Dec_fflush(stream));
}


int		dec_fgetc(FILE *stream)
{
	return (g_pDecIO->Dec_fgetc(stream));
}


char	*dec_fgets(char *string, int n, FILE *stream)
{
	return (g_pDecIO->Dec_fgets(string, n, stream));
}


FILE	*dec_fopen(const char *filename, const char *mode)
{
	return (g_pDecIO->Dec_fopen(filename, mode));
}


int		dec_fputc(int c, FILE *stream)
{
	return (g_pDecIO->Dec_fputc(c, stream));
}


int		dec_fputs(const char *string, FILE *stream)
{
	return (g_pDecIO->Dec_fputs(string, stream));
}


size_t	dec_fread(void *buffer, size_t size, size_t count, FILE *stream)
{
	return (g_pDecIO->Dec_fread(buffer, size, count, stream));
}


int		dec_fseek(FILE *stream, long offset, int origin)
{
	return (g_pDecIO->Dec_fseek(stream, offset, origin));
}


long	dec_ftell(FILE *stream)
{
	return (g_pDecIO->Dec_ftell(stream));
}


int		dec_ftruncate(FILE *stream, size_t size)
{
	return (g_pDecIO->Dec_ftruncate(stream, size));
}


size_t	dec_fwrite(const void *buffer, size_t size, size_t count, FILE *stream)
{
	return (g_pDecIO->Dec_fwrite(buffer, size, count, stream));
}


int		dec_remove(const char *path)
{
	return (g_pDecIO->Dec_remove(path));
}


int		dec_rename(const char *oldname, const char *newname)
{
	return (g_pDecIO->Dec_rename(oldname, newname));
}


void	dec_rewind(FILE *stream)
{
	g_pDecIO->Dec_rewind(stream);
	return;
}


int		dec_setvbuf(FILE *stream, char *buffer, int mode, size_t size)
{
	return (g_pDecIO->Dec_setvbuf(stream, buffer, mode, size));
}


#if defined(_WINDOWS)
int		dec_stat(const char *path, struct _stat *buffer)
#else
int		dec_stat(const char *path, struct stat *buffer)
#endif
{
	return (g_pDecIO->Dec_stat(path, buffer));
}


int		dec_ungetc(int c, FILE *stream)
{
	return (g_pDecIO->Dec_ungetc(c, stream));
}


#if defined(_WINDOWS)
int		dec_utime(const char *filename, struct _utimbuf *times)
#else
int		dec_utime(const char *filename, struct utimbuf *times)
#endif
{
	return (g_pDecIO->Dec_utime(filename, times));
}

#endif // if defined(BYPASS_DECSDK)

int		dec_fprintf(FILE *stream, const char *format, ...)
{
	#define MAX_TRIES 10
	#define MAX_BUFFER_SIZE 1024
	
	int		nLen = 0;
	int		nRetval = -1;

#if defined(NO_VSNPRINTF)
	char szBuffer[MAX_BUFFER_SIZE * 4];

	//
	// Format the string
	//
	try
	{
		va_list arglist;
		va_start(arglist, format);
		nLen = vsprintf(szBuffer, format, arglist); // unsafe because in NO_VSNPRINTF code block
		va_end(arglist);
	}

	catch(...)
	{
		dec_assert(0);
		return 0;
	}

	if (nLen > 0)
		nRetval = dec_fwrite(szBuffer, sizeof(char), nLen, stream);

#else
	int		nNumberOfRetries = 0;
	int		nBufferSize = MAX_BUFFER_SIZE;
	char	*pszTemp;
	va_list vl;
	
	va_start(vl, format);

	pszTemp = (char *)malloc(nBufferSize);
	if (!pszTemp)
		return (-1);

	while (true)
	{
		// There are some non-standard versions of vsnprintf() that do not
		// conform to either the C99 standard, or their own documentation.
		// 
		// vsnprintf() may return -1 if the buffer is not big enough, or
		// it may return the number of characters that would be needed to
		// create the full string, exclusive of the terminating NUL. We
		// will handle both cases. If -1 is returned, we will advance the 
		// buffer size by our increment amount. If a size is returned, we 
		// will use it (+1 for the NUL) on the next pass.

		// Dave VW 8/17/2005: replaced vsnprintf() with ssvsnprintf() which is known to comply with C99
		nLen = ssvsnprintf(pszTemp, nBufferSize, format, vl); 
		if ((nLen >= 0) && (nLen < nBufferSize))
		{
			// Successfully formatted the output buffer so write it out.
			nRetval = dec_fwrite(pszTemp, sizeof(char), nLen, stream);
			break;
		}

		// Failed to format the output buffer so try again but with
		// a larger buffer.
		nNumberOfRetries++;
		if (nNumberOfRetries > MAX_TRIES)
			break;

		// See if we can get the right buffer size now...
		if ((nLen > 0) && (nLen >= nBufferSize))
			nBufferSize = nLen + 1;
		else
			nBufferSize += MAX_BUFFER_SIZE;

		{
			char* pszRealloced = (char *)realloc(pszTemp, nBufferSize);
			if (!pszRealloced)
			{
				free(pszTemp);
				pszTemp = NULL;
				break;
			}
			pszTemp = pszRealloced;
		}

		//
		// Each call to vsnprintf changes vl.  So, we need to reset it
		// each time.
		//
		va_start(vl, format);
	}

	va_end(vl);

	if (pszTemp)
		free(pszTemp);
#endif

	return nRetval;
}

