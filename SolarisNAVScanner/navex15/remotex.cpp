//************************************************************************
//
// $Header:   S:/NAVEX/VCS/remotex.cpv   1.1   24 Dec 1998 23:54:30   DCHI  $
//
// Description:
//  Contains implementation of W32.RemoteExplorer repair
//
//************************************************************************
// $Log:   S:/NAVEX/VCS/remotex.cpv  $
// 
//    Rev 1.1   24 Dec 1998 23:54:30   DCHI
// 
//    Rev 1.0   24 Dec 1998 23:02:16   DCHI
// Initial revision.
// 
//************************************************************************

#include "gdefines.h"

#include "ssbstype.h"
#include "df.h"
#include "callback.h"

#include "remotex.h"

#ifdef SYM_WIN16
#pragma data_seg("FAR_DATA_0")
#endif

// gabyRemoteXGZipHdr[] is the GZIP header that RemoteX
//  places in front of the Deflate compressed block
//
// See RFC 1952.txt for meaning of GZip header fields

const BYTE FAR gabyRemoteXGZipHdr[10] =
{
    0x1F, 0x8B, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B
};

// These ten bytes are the encrypted form of the above at
//  offset 10 of non-EXEs touched by RemoteX

const BYTE FAR gabyRemoteXEncryptedGZipHdr[10] =
{
    0x51, 0xF3, 0xD0, 0x9F, 0x5C, 0x86, 0x3B, 0x31, 0x5B, 0xA5
};

// The following tables are used for decrypting the
//  encrypted GZIP block that RemoteX performs on non-EXEs

#define REMOTEX_NUM_TABLE_LINES         11

const BYTE FAR gabyRemoteXBitTable[REMOTEX_NUM_TABLE_LINES][8] =
{
    { 0x20, 0x01, 0x08, 0x10, 0x04, 0x02, 0x80, 0x40 },
    { 0x01, 0x10, 0x02, 0x20, 0x04, 0x40, 0x08, 0x80 },
    { 0x08, 0x02, 0x80, 0x40, 0x01, 0x04, 0x20, 0x10 },
    { 0x20, 0x04, 0x08, 0x10, 0x02, 0x40, 0x80, 0x01 },
    { 0x40, 0x01, 0x08, 0x02, 0x04, 0x10, 0x80, 0x20 },
    { 0x08, 0x20, 0x80, 0x01, 0x40, 0x04, 0x02, 0x10 },
    { 0x04, 0x02, 0x80, 0x10, 0x01, 0x08, 0x40, 0x20 },
    { 0x80, 0x40, 0x20, 0x08, 0x10, 0x04, 0x02, 0x01 },
    { 0x02, 0x40, 0x80, 0x01, 0x20, 0x10, 0x08, 0x04 },
    { 0x02, 0x80, 0x40, 0x01, 0x10, 0x04, 0x20, 0x08 },
    { 0x08, 0x04, 0x10, 0x02, 0x01, 0x40, 0x80, 0x20 }
};

const BYTE FAR gabyRemoteXSwitchTable[REMOTEX_NUM_TABLE_LINES][2] =
{
    { 1, 5 },
    { 1, 1 },
    { 2, 1 },
    { 4, 2 },
    { 3, 1 },
    { 5, 4 },
    { 3, 2 },
    { 2, 2 },
    { 3, 5 },
    { 2, 4 },
    { 3, 3 }
};

const signed char FAR gasbyRemoteXPMTable[REMOTEX_NUM_TABLE_LINES][2] =
{
    { -1, -1 },
    { +1, +1 },
    { +1, +1 },
    { +1, -1 },
    { -1, +1 },
    { -1, -1 },
    { +1, -1 },
    { +1, +1 },
    { +1, -1 },
    { -1, +1 },
    { +1, -1 }
};

#define REMOTEX_41E9A0_SIZE     0x4C

const BYTE FAR gabyRemoteX41E9A0[] =
{
    0x04, 0x02, 0x1E, 0x86, 0x02, 0x66, 0x09, 0x08,
    0x4D, 0xA4, 0xA4, 0xEE, 0x77, 0x66, 0xEC, 0x5E,
    0x97, 0x55, 0x00, 0xA6, 0x02, 0x84, 0xA6, 0x93,
    0xCA, 0x55, 0x0C, 0x36, 0xC4, 0xC9, 0x94, 0x1A,
    0xCA, 0x2D, 0x4E, 0x51, 0x59, 0x06, 0x40, 0x0B,
    0xE6, 0xF7, 0x98, 0xF8, 0x34, 0xB9, 0x80, 0xE8,
    0x15, 0x26, 0xE1, 0xD3, 0xF1, 0xE3, 0xFE, 0x5E,
    0x9D, 0xA4, 0xA1, 0xA7, 0x91, 0x36, 0x35, 0x16,
    0xA9, 0x54, 0xFE, 0x10, 0x31, 0xF8, 0x9E, 0x7F,
    0x3A, 0x40, 0x6D, 0x2E
};

#ifdef SYM_WIN16
#pragma data_seg()
#endif

//********************************************************************
//
// Function:
//  BOOL RemoteXRestoreHost()
//
// Parameters:
//  lpstCallBack        Ptr to callbacks
//  hFile               File handle
//  dwHostOffset        Offset of GZip header
//  dwHostSize          Size of GZip block
//  lpabyWorkBuffer     Ptr to work buffer
//  dwWorkBufSize       Size of work buffer
//
// Description:
//  The given dwHostOffset is the offset of the GZip header that
//  begins the compressed block containing the compressed host.
//  The function first validates that the GZip header is consistent
//  with the one generated by RemoteX.  If it is different, the
//  function returns error.
//
//  The Deflate compressed block (RFC1951) immediately follows
//  the GZip header.  The block is decompressed to the EOF.
//  The decompressed host is then moved to the beginning of the
//  file and the file is truncated at the end of the moved host.
//
// Returns:
//  TRUE                On success
//  FALSE               On error
//
//********************************************************************

BOOL RemoteXRestoreHost
(
    LPCALLBACKREV1      lpstCallBack,
    HFILE               hFile,
    DWORD               dwHostOffset,
    DWORD               dwHostSize,
    LPBYTE              lpabyWorkBuffer,
    DWORD               dwWorkBufSize
)
{
    LPCALLBACKREV1      lpstModCallBack;
    BOOL                bResult;
    BYTE                abyHdr[10];
    int                 i;
    LPREMOTEXCB         lpstRemoteXCB;

    ////////////////////////////////////////////////////////
    // Allocate memory

    // Allocate structure with REMOTEXCB_T structure

    if (DFMemoryAlloc(lpstCallBack,
                      sizeof(CALLBACKREV1) + sizeof(REMOTEXCB_T),
                      (LPLPVOID)&lpstModCallBack) != DF_STATUS_OK)
        return(FALSE);

    bResult = TRUE;

    ////////////////////////////////////////////////////////
    // Set up the modified callback

    *lpstModCallBack = *lpstCallBack;
    lpstModCallBack->FileOpen = NULL;
    lpstRemoteXCB = (LPREMOTEXCB)(lpstModCallBack + 1);
    lpstRemoteXCB->hFile = hFile;

    // Read the header

    if (lpstCallBack->FileSeek(hFile,dwHostOffset,0) == (DWORD)-1 ||
        lpstCallBack->FileRead(hFile,abyHdr,10) != 10)
        bResult = FALSE;

    // Verify the header

    for (i=0;i<10;i++)
    {
        if (abyHdr[i] != gabyRemoteXGZipHdr[i])
            bResult = FALSE;
    }

    // Determine the offset of the first block

    lpstRemoteXCB->dwSrcBaseOffset = lpstRemoteXCB->dwSrcCurOffset =
        dwHostOffset + 10;

    // Get the EOF offset

    lpstRemoteXCB->dwDstBaseOffset = lpstRemoteXCB->dwDstCurOffset =
        lpstCallBack->FileSize(hFile);

    if (lpstRemoteXCB->dwDstBaseOffset == (DWORD)-1)
        bResult = FALSE;

    // Validate the base offsets

    if (lpstRemoteXCB->dwDstBaseOffset < lpstRemoteXCB->dwSrcBaseOffset ||
        dwHostSize <= 10)
        bResult = FALSE;

    ////////////////////////////////////////////////////////
    // Decompress

    if (bResult != FALSE)
    {
        LPIF        lpstIF;
        DWORD       dwSize;
        DWORD       dwOffset;
        DWORD       dwIOSize;
        DWORD       dwGZipSpecCRC;
        DWORD       dwGZipSpecSize;

        // Allocate an inflation structure

        lpstIF = IFAllocIF(lpstModCallBack);
        if (lpstIF == NULL)
            bResult = FALSE;
        else
        {
            // Initialize the inflation structure

            if (bResult != FALSE)
            {
                if (IFInit(lpstIF,
                           (LPVOID)0,
                           0,
                           dwHostSize - 10) == FALSE)
                    bResult = FALSE;
            }

            // Inflate

            if (bResult != FALSE)
            {
                if (IFInflate(lpstIF,
                              (LPVOID)1) == FALSE)
                {
                    // Delete the result if there was an error

                    lpstCallBack->FileSeek(hFile,
                                           lpstRemoteXCB->dwDstBaseOffset,
                                           0);

                    lpstCallBack->FileWrite(hFile,lpabyWorkBuffer,0);

                    bResult = FALSE;
                }
                else
                {
                    // Inflation was successful
                    //  Get the offset of the CRC and the size

                    dwOffset = lpstRemoteXCB->dwSrcBaseOffset +
                        lpstIF->dwNextReadOffset -
                        lpstIF->nReadAheadByteCount +
                        lpstIF->nReadAheadI;

                    if (lpstCallBack->FileSeek(hFile,
                                               dwOffset,
                                               0) == (DWORD)-1 ||
                        lpstCallBack->FileRead(hFile,
                                               &dwGZipSpecCRC,
                                               sizeof(DWORD)) != sizeof(DWORD) ||
                        lpstCallBack->FileRead(hFile,
                                               &dwGZipSpecSize,
                                               sizeof(DWORD)) != sizeof(DWORD))
                    {
                        bResult = FALSE;
                    }
                    else
                    {
                        // Check the specified and computed CRC

                        if (dwGZipSpecCRC != ~lpstIF->dwCRC)
                            bResult = FALSE;
                    }
                }
            }

            IFFreeIF(lpstIF);

            if (bResult != FALSE)
            {
                // Get the size

                lpstRemoteXCB->dwDstCurOffset =
                    lpstCallBack->FileSize(hFile);

                dwSize = lpstRemoteXCB->dwDstCurOffset -
                    lpstRemoteXCB->dwDstBaseOffset;

                // Check the specified and computed size

                if (dwGZipSpecSize != dwSize)
                    bResult = FALSE;
                else
                {
                    // Move to beginning of file

                    dwOffset = 0;
                    dwIOSize = dwWorkBufSize;
                    while (dwOffset < dwSize)
                    {
                        if (dwSize - dwOffset < dwIOSize)
                            dwIOSize = dwSize - dwOffset;

                        if (lpstCallBack->
                                FileSeek(hFile,
                                         lpstRemoteXCB->dwDstBaseOffset + dwOffset,
                                         0) == (DWORD)-1 ||
                            lpstCallBack->
                                FileRead(hFile,
                                         lpabyWorkBuffer,
                                         (UINT)dwIOSize) != (UINT)dwIOSize)
                        {
                            bResult = FALSE;
                            break;
                        }

                        if (lpstCallBack->
                                FileSeek(hFile,
                                         dwOffset,
                                         0) == (DWORD)-1 ||
                            lpstCallBack->
                                FileWrite(hFile,
                                          lpabyWorkBuffer,
                                          (UINT)dwIOSize) != (UINT)dwIOSize)
                        {
                            bResult = FALSE;
                            break;
                        }

                        dwOffset += dwIOSize;
                    }

                    // Truncate

                    if (bResult != FALSE)
                    {
                        lpstCallBack->FileSeek(hFile,
                                               dwSize,
                                               0);

                        lpstCallBack->FileWrite(hFile,lpabyWorkBuffer,0);
                    }
                }
            }
        }
    }

    // Free the modified callback

    DFMemoryFree(lpstCallBack,lpstModCallBack);

    return(bResult);
}


//********************************************************************
//
// Function:
//  void RemoteXDecryptChunk()
//
// Parameters:
//  lpstX               Ptr to decryption state structure
//  lpabyChunk          Ptr to chunk to decrypt
//  dwNumBytes          Number of bytes in the chunk
//
// Description:
//  The function decrypts the RemoteX encrypted chunk by
//  reversing the encryption process.
//
// Returns:
//  TRUE                On success
//  FALSE               On error
//
//********************************************************************

typedef struct tagREMOTEX_DECRYPT
{
    BYTE                aby41DD60[8];
    BYTE                aby41DD68[8];
    BYTE                by41DD70;
    BYTE                by41E9F0;
} REMOTEX_DECRYPT_T, FAR *LPREMOTEX_DECRYPT;

void RemoteXDecryptChunk
(
    LPREMOTEX_DECRYPT   lpstX,
    LPBYTE              lpabyChunk,
    DWORD               dwNumBytes
)
{
    DWORD               dwI;
    int                 nVal;
    int                 i;
    int                 nRes0, nRes1;
    BYTE                byArg10;
    BYTE                bySrc;
    BYTE                byDst;
    LPBYTE              lpabyBitChange;

    for (dwI=0;dwI<dwNumBytes;dwI++)
    {
        byArg10 = gabyRemoteX41E9A0[lpstX->by41E9F0];
        if (byArg10 & 0x80)
            nVal = 0;
        else
            nVal = byArg10 % REMOTEX_NUM_TABLE_LINES;

        nRes0 = (int)lpstX->by41DD70 - gabyRemoteXSwitchTable[nVal][0];
        if (nRes0 < 0) nRes0 += 8;

        nRes1 = (int)lpstX->by41DD70 - gabyRemoteXSwitchTable[nVal][1];
        if (nRes1 < 0) nRes1 += 8;

        byArg10 += gasbyRemoteXPMTable[nVal][0] * lpstX->aby41DD60[nRes0] +
            gasbyRemoteXPMTable[nVal][1] * lpstX->aby41DD68[nRes1];

        lpabyBitChange = (LPBYTE)&gabyRemoteXBitTable[nVal][0];

        ////////////////////////////////////////////////////
        // The following is XSub2B5E

        bySrc = *lpabyChunk;
        byDst = 0;

        for (i=0;i<8;i++)
        {
            if (bySrc & lpabyBitChange[i])
                byDst |= (1 << i);
        }

        byDst -= byArg10;

        *lpabyChunk = byDst;

        ////////////////////////////////////////////////////
        // The following is XSub2B31

        lpstX->aby41DD60[lpstX->by41DD70] = byDst;
        lpstX->aby41DD68[lpstX->by41DD70] = bySrc;
        if (++lpstX->by41DD70 == 8)
            lpstX->by41DD70 = 0;

        ////////////////////////////////////////////////////

        ++lpabyChunk;
        lpstX->by41E9F0 = (lpstX->by41E9F0 + 1) % REMOTEX_41E9A0_SIZE;
    }
}


//********************************************************************
//
// Function:
//  BOOL RemoteXDecryptNonEXEHost()
//
// Parameters:
//  lpstCallBack        Ptr to callbacks
//  hFile               File handle
//  dwBlkSize           Size of the encrypted block
//  dwFileSize          Size of the file
//  lpabyWorkBuffer     Ptr to work buffer
//  dwWorkBufSize       Size of work buffer
//
// Description:
//  The function assumes that the encrypted block begins at offset
//  ten of the file.  The encrypted block has the given size,
//  dwBlkSize.  It is decrypted to the end of the file in chunks
//  the size of the work buffer.  The offset of the end of the
//  file is given by dwFileSize.
//
// Returns:
//  TRUE                On success
//  FALSE               On error
//
//********************************************************************

BOOL RemoteXDecryptNonEXEHost
(
    LPCALLBACKREV1      lpstCallBack,
    HFILE               hFile,
    DWORD               dwBlkSize,
    DWORD               dwFileSize,
    LPBYTE              lpabyWorkBuffer,
    DWORD               dwWorkBufSize
)
{
    int                 i;
    REMOTEX_DECRYPT_T   stX;
    DWORD               dwIOSize;
    DWORD               dwOffset;
    BOOL                bResult;

    // Initialize the decryption structure

    for (i=0;i<8;i++)
    {
        stX.aby41DD60[i] = 0;
        stX.aby41DD68[i] = 0;
    }

    stX.by41DD70 = 0;
    stX.by41E9F0 = 0;

    // Decrypt

    bResult = TRUE;
    dwOffset = 0;
    dwIOSize = dwWorkBufSize;
    while (dwOffset < dwBlkSize)
    {
        if (dwBlkSize - dwOffset < dwIOSize)
            dwIOSize = dwBlkSize - dwOffset;

        // Read a chunk

        if (lpstCallBack->FileSeek(hFile,
                                   10 + dwOffset,
                                   0) == (DWORD)-1 ||
            lpstCallBack->FileRead(hFile,
                                   lpabyWorkBuffer,
                                   (UINT)dwIOSize) != (UINT)dwIOSize)
        {
            bResult = FALSE;
            break;
        }

        // Decrypt the chunk

        RemoteXDecryptChunk(&stX,lpabyWorkBuffer,dwIOSize);

        // Write the decrypted chunk to the end

        if (lpstCallBack->FileSeek(hFile,
                                   dwFileSize + dwOffset,
                                   0) == (DWORD)-1 ||
            lpstCallBack->FileWrite(hFile,
                                    lpabyWorkBuffer,
                                    (UINT)dwIOSize) != (UINT)dwIOSize)
        {
            bResult = FALSE;
            break;
        }

        dwOffset += dwIOSize;
    }

    return(bResult);
}


//********************************************************************
//
// Function:
//  BOOL RemoteXRestoreNonEXEHost()
//
// Parameters:
//  lpstCallBack        Ptr to callbacks
//  hFile               File handle
//  lpabyWorkBuffer     Ptr to work buffer
//  dwWorkBufSize       Size of work buffer
//
// Description:
//  The function reads the first 10 bytes of the file and verifies
//  that the two bytes at offset two are {0x03,0x05} and that
//  the two bytes at offset eight are {0x09,0x54}.  RemoteX
//  uses these byte values to determine whether or not the file
//  has been encrypted for non-EXEs.
//
//  The encrypted file is the same size as the original file
//  with the first 10 bytes serving as the header.  The header
//  includes the four constant bytes described in the first
//  paragraph.  The first two bytes of the header are left the
//  same as the original file.  The DWORD at offset four is the
//  size of the encrypted GZip compressed block.
//
//  The function decrypts the GZip compressed block to the
//  end of the file and then decompresses the decrypted block
//  to restore the host.
//
// Returns:
//  TRUE                On success
//  FALSE               On error
//
//********************************************************************

BOOL RemoteXRestoreNonEXEHost
(
    LPCALLBACKREV1      lpstCallBack,
    HFILE               hFile,
    LPBYTE              lpabyWorkBuffer,
    DWORD               dwWorkBufSize
)
{
    BYTE                abyHdr[10];
    DWORD               dwBlkSize;
    DWORD               dwFileSize;
    int                 i;
    BOOL                bResult;

    // Get the header

    if (lpstCallBack->FileSeek(hFile,0,0) != 0 ||
        lpstCallBack->FileRead(hFile,abyHdr,10) != (UINT)10)
        return(FALSE);

    // Validate the header bytes

    if (abyHdr[2] != 0x03 || abyHdr[3] != 0x05 ||
        abyHdr[8] != 0x09 || abyHdr[9] != 0x54)
        return(FALSE);

    // Get the size of the compressed block

    dwBlkSize = ((DWORD)abyHdr[4]) |
                (((DWORD)abyHdr[5]) << 8) |
                (((DWORD)abyHdr[6]) << 16) |
                (((DWORD)abyHdr[7]) << 24);

    // Get the file size and validate that the block size
    //  plus the 10-byte header fit in the file

    dwFileSize = lpstCallBack->FileSize(hFile);
    if (dwFileSize == (DWORD)-1 ||
        dwBlkSize > dwFileSize ||
        dwFileSize - dwBlkSize < 10)
        return(FALSE);

    // Get the encrypted GZip header

    if (lpstCallBack->FileRead(hFile,abyHdr,10) != (UINT)10)
        return(FALSE);

    // Validate the encrypted GZip header

    for (i=0;i<10;i++)
    {
        if (abyHdr[i] != gabyRemoteXEncryptedGZipHdr[i])
            bResult = FALSE;
    }

    // Initialize result

    bResult = TRUE;

    // Decrypt the host to the end of the file

    if (RemoteXDecryptNonEXEHost(lpstCallBack,
                                 hFile,
                                 dwBlkSize,
                                 dwFileSize,
                                 lpabyWorkBuffer,
                                 dwWorkBufSize) == FALSE)
        bResult = FALSE;

    // Restore the host

    if (RemoteXRestoreHost(lpstCallBack,
                           hFile,
                           dwFileSize,  // Offset of GZip block
                           dwBlkSize,
                           lpabyWorkBuffer,
                           dwWorkBufSize) == FALSE)
        bResult = FALSE;

    // Try to clean up if there was an error

    if (bResult == FALSE)
    {
        // Attempt to restore the file by truncating at the file size

        lpstCallBack->FileSeek(hFile,dwFileSize,0);
        lpstCallBack->FileWrite(hFile,lpabyWorkBuffer,0);
    }

    return(bResult);
}

