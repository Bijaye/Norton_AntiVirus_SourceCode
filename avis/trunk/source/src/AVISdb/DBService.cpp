//
//	IBM AntiVirus Immune System
//
//	File Name:	DBService.cpp
//	Author:		Andy Klapper
//
//	This class represents the database handle.  Each process should have
//	one database handle.  This code enforces this rule by only opening
//	one database handle per process.
//
//	OpenService		This static method opens the database.
//	CloseService	This static method closes the database.
//	GetErrorMessage	This static method returns an error message (if any)
//					that was generated by the last Open/Close Database call.
//
//	$Log: /DBService/DBService/DBService.cpp $
//
//1     8/19/98 9:10p Andytk
//Initial check in.
//
//1     8/19/98 9:10p Andytk
//Initial check in
//

#include "stdafx.h"

#include <iostream>

#include <CMclCritSec.h>
#include <CMclAutoLock.h>

#include "DBService.h"


unsigned int	DBService::useCount			= 0;
SQLHANDLE		DBService::sqlEnvironment	= 0;
RETCODE			DBService::retcode			= 0;
std::string		DBService::databaseName		= "";


bool DBService::OpenService(const std::string& dbName)
{
    bool    rc      = false;

	if (0 < useCount)
	{
		if (dbName == databaseName)
		{
			rc	= true;
			++useCount;
		}
	}
	else
	{
		static CMclCritSec	initializing;

		CMclAutoLock	lock(initializing);	// only one thread does the init
		if (0 == useCount)					// are we the first or did init
		{									// happen while waiting?
			retcode = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE,
				                      &sqlEnvironment);
			if (SQL_SUCCESS == retcode || SQL_SUCCESS_WITH_INFO == retcode)
			{
				retcode = SQLSetEnvAttr(sqlEnvironment, SQL_ATTR_ODBC_VERSION,
					                    (void*) SQL_OV_ODBC3, 0);
				if (SQL_SUCCESS == retcode || SQL_SUCCESS_WITH_INFO == retcode)
				{
					rc = true;
					++useCount;
					databaseName = dbName;
				}
				else
				{
					std::string	errMsg("Error in OpenService, (SQLSetEnvAttr) [ ");
					std::string details;
					GetErrorMessage(details);
					errMsg	+= details;
					errMsg	+= " ]";
					RETCODE retcode2 = retcode;
					CloseService();
					retcode = retcode2;

					throw AVISDBException(AVISDBException::etDBService, errMsg);
				}
			}
			else
			{
				std::string	errMsg("Error in OpenService, (SQLAllocHandle)");

				throw AVISDBException(AVISDBException::etDBService, errMsg);
			}
		}
		else
			++useCount;
	}
//std::cerr << "sqlEnvironment " << sqlEnvironment << "\n";

    return rc;
}


bool DBService::CloseService()
{
	bool	rc	= true;

//std::cerr << "CloseService, useCount = " << useCount << "\n";

	if (1 == useCount)
	{
		retcode = SQLFreeHandle(SQL_HANDLE_ENV, sqlEnvironment);
		rc		= (SQL_SUCCESS == retcode || SQL_SUCCESS_WITH_INFO == retcode);
	}
	if (useCount > 0)
		--useCount;
	else
	{
		throw AVISDBException(AVISDBException::etDBService,
								"CloseService, useCount dropped below zero!");
	}

    return rc;
}


bool DBService::GetErrorMessage(std::string& errorMessage)
{
	SQLCHAR		sqlState[6];
	SQLINTEGER	nativeErrorPtr;
static	SQLCHAR		messageText[1024];
	SQLSMALLINT	textLengthPtr;
	RETCODE		rc;

	errorMessage = "";

	for (int i = 1;
		 SQL_SUCCESS == (rc = SQLGetDiagRec( SQL_HANDLE_ENV, sqlEnvironment, 1,
										sqlState, &nativeErrorPtr,
										messageText, 1024, &textLengthPtr)) ||
		 SQL_SUCCESS_WITH_INFO == rc;
		 i++)
	{
		if (0 < errorMessage.size())
			errorMessage += "\n";

		errorMessage += (char *) messageText;
	}

	return 0 < errorMessage.size();
}
