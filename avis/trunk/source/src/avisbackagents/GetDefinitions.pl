############################################################################
# GetDefinitions.pl
# This program imports FatAlbert packages from the back office.
# These packages are usually created by humans who work outside
# the Immune System analysis center. This program uses the SDGS.pm
# (Symantec Definition Generation Service) which was provided
# by Symantec in July/1999. This program imports both the newest
# and the blessed definition packages from the back office if
# they are available. This program will continue to work with the Symantec's
# version of SDGS.pm in the future.
#
# Note:
# -----
# For the Immune System pilot, there will not be any manual
# definition generations taking place since there is no back office.
# However, it is necessary to import the new definition packages
# generated by SARC in Santa Monica, CA into the analysis center.
# In order to do that, we are implementing a temporary solution to
# get the FatAlbert packages. This implementation is done in the
# SDGS1.pm. After the pilot is over and when the Immune System is
# run in production in Santa Monica, we will have to change in this file
# every occurrance of the string "SDGS1" to "SDGS". Also remember that
# the original back office def import functions written by Symantec 
# in SDGS.PM were not tested that well. Those 2 original functions
# in SDGS.PM will have to be tested with the GetDefinitions.pl file
# sometime after the pilot is over.
#
#
# Authors: Michael Wilson, Senthil Velayudham, Srikant Jalan
#
# The specification for SDGS is available in a detailed
# document titled "Definition Generation Service API specifications".
# 
############################################################################
# Mon Dec 13 15:17:05 1999: MPW
#--------------------------------------------------------------------------- 
# In order to support VDB packages, I have made several changes to
# this module...
#--------------------------------------------------------------------------- 
# * GetDefinitions.pl: A new global constant has been added
#      "$package_extension" to coincide with the $packageType
#      constant.  All places where the package filename is refered to
#      with an explicit ".exe" I have changed the string to read
#      ".$package_extension" to facilitate flexibility of multiple
#      package type support.
#---------------------------------------------------------------------------
# Senthil has also requested the following change:
#---------------------------------------------------------------------------
#  * GetDefinitions.pl: At Senthil's request I have commented out the
# 	"use SDGS1;" line while making my VDB package changes.  I'm
# 	not terribly familiar with the repercussions of this. In all
# 	instances where the string SDGS1 occurred, I have created a
# 	duplicate of the line, commented it out, and changed the
# 	"live" source to read SDGS in the appropriate places.
#
############################################################################

# Define all the perl modules that are required in this program.
use Getopt::Long;
use DataFlow;
use SDGS;
#    use SDGS1;
use strict;
use md5;
use File::Basename;
use AVIS::Local;
use BOSupport;
use Win32::ODBC;

# Parse the command line arguments from @ARGV.
my ($Cookie, $ProcessID, $Parameter, $unc);

GetOptions("Cookie=i"    => \$Cookie,
	   "ProcessId=i" => \$ProcessID,
	   "Parameter=s" => \$Parameter,
	   "UNC=s"       => \$unc);

print "Cookie: $Cookie, ProcessId: $ProcessID, Parameter: $Parameter, UNC: $unc\n";

# Define all the local variables used in this program.
my ($status, $defImporterLogFileName);
my ( $packageFileName, $signatureStorageDirBase); 

# Initialize some of the local variables.
my $defImporterBaseDir = "$isdnServerRoot\\BackOfficeDefinitionImporter";

my $newerSequence   = 0;
my $blessedSequence = 0;

# Definition packaging configuration
my $packageType       = "VDB";
my $package_extension = "vdb";
# my $packageType       = "FatAlbert";
# my $package_extension = "exe";

# Package filename and the signature directory are passed by the DataFlow program in the
# --Parameter command line argument. Split them from that argument.
($signatureStorageDirBase, $packageFileName) = split /\s/, $Parameter;         
# Due to problems in navdef extraction to UNC dir, we decided to hard code the packageFileName to a 
# file on the local drive. (Change made on NOV/08/1999)
$packageFileName = "c:\\temp\\defpkg.$package_extension";
$defImporterLogFileName = "$defImporterBaseDir\\BackOfficeDefImporter.log";

# Delete the dataflow result and stop files if they already exist.
my $dfresultFileName = "$unc\\dfresults\\Result$ProcessID.dat";
my $dfStopFileName = "$unc\\dfresults\\Stop$ProcessID.dat";

if (-e $dfresultFileName)
  {
    # Delete the dfresult file if it already exists.
    unlink ($dfresultFileName);
  }

if (-e $dfStopFileName)
  {
    # Delete the dfstop file if it already exists.
    unlink ($dfStopFileName);
  }

# If the definition importer directory is not there, create it.
if (!(-d $defImporterBaseDir))
  {
    mkdir ($defImporterBaseDir, 777);
  }

# Rename the log file to a backup if the size exceeds 1MB. 
if (-e $defImporterLogFileName)
  {
    my $logFileSize;
    $logFileSize = -s $defImporterLogFileName;
    
    if ($logFileSize > 1024000)
      {
        system ("copy $defImporterLogFileName $defImporterLogFileName.bak");
        unlink ($defImporterLogFileName);
      }
  }         

# Create or open the log file.
if (-e $defImporterLogFileName)
  {               
    open (LOGFILEHANDLE, ">>$defImporterLogFileName ");
  }
else
  {
    open (LOGFILEHANDLE, ">$defImporterLogFileName "); 
  }

print LOGFILEHANDLE ("========================================================\n");
print LOGFILEHANDLE ("Cookie: $Cookie, ProcessId: $ProcessID, Parameter: $Parameter, UNC: $unc\n");
print LOGFILEHANDLE ("packageFileName = $packageFileName, signatureStorageDirBase = $signatureStorageDirBase\n");

my ($db, $sqlStatement, $rc, %Data);
# Create an ODBC object to make transactions with AVISDATA.
#$db = new Win32::ODBC ("dsn=" . $db2DSN . ";uid=" . $db2UserID . ";pwd=" . $db2Password);
$db = new Win32::ODBC ("dsn=" . $db2DSN);

# If we are unable to get an ODBC object, return from this function now.
if ($db == undef)
  {
    print LOGFILEHANDLE (getCurrentTime() . "Error in <new Win32::ODBC>.\n");
    exit;
  }


##########   BEGIN GET THE NEWEST SEQUENCE NUMBER FROM THE GLOBALS TABLE ####################
# Define some local variables and initialize them.
my ($newestSeqNum, $newestBlssdSeqNum, $criticalError);
$newestSeqNum = 0;
$newestBlssdSeqNum = 0;
$criticalError = 0; 

print LOGFILEHANDLE (getCurrentTime() . "Creating and executing the SQL file for getting the newest sequence number.\n"); 
# Form an SQL statement for getting the NewestSeqNum from the Globals table and execute the SQL statement.
$sqlStatement = "SELECT NEWESTSEQNUM FROM GLOBALS";
$rc = $db->Sql ($sqlStatement);

# Check for any SQL execution errors.
if ($rc)
  {
    print LOGFILEHANDLE (getCurrentTime() . "Sql Failed. Error =" . $db->Error (). "\n");
  }
else
  {
    # Stay in a loop to process all the rows of the previous SQL execution.
    while ($db->FetchRow ())
      {
        undef %Data;
        # Read the value of the NEWESTSEQNUM column into the hash.
        %Data = $db->DataHash ("NEWESTSEQNUM");
        $newestSeqNum = $Data {NEWESTSEQNUM};
        # Since we got the NewestSeqNum, exit the loop after the first iteration.
        last;
      }
  }

print LOGFILEHANDLE (getCurrentTime() . "NewestSequenceNumber read from the database = $newestSeqNum.\n");  

##########   END GET THE NEWEST SEQUENCE NUMBER FROM THE GLOBALS TABLE ####################

##########   BEGIN GET THE BLESSED SEQUENCE NUMBER FROM THE GLOBALS TABLE ####################

print LOGFILEHANDLE (getCurrentTime() . "Creating and executing the SQL file for getting the newest blessed sequence number.\n"); 
# Form an SQL statement for getting the NewestBlessedSeqNum from the Globals table and execute the SQL statement.
$sqlStatement = "SELECT NEWESTBLSSDSEQNUM FROM GLOBALS";
$rc = $db->Sql ($sqlStatement);

# Check for any SQL execution errors.
if ($rc)
  {
    print LOGFILEHANDLE (getCurrentTime() . "Sql Failed. Error =" . $db->Error (). "\n");
  }
else
  {
    # Stay in a loop to process all the rows of the previous SQL execution.
    while ($db->FetchRow ())
      {
        undef %Data;
        
        # Read the value of the NEWESTBLSSDSEQNUM column into the hash.
        %Data = $db->DataHash ("NEWESTBLSSDSEQNUM");
        $newestBlssdSeqNum = $Data {NEWESTBLSSDSEQNUM};
        # Since we got the NewestBlessedSeqNum, exit the loop after the first iteration.
        last;
      }
  }

print LOGFILEHANDLE (getCurrentTime() . "NewestBlessedSequenceNumber read from the database = $newestBlssdSeqNum.\n");  

##########   END GET THE BLESSED SEQUENCE NUMBER FROM THE GLOBALS TABLE ####################

print "newestSeqNum = $newestSeqNum, newestBlssdSeqNum = $newestBlssdSeqNum\n";

print LOGFILEHANDLE (getCurrentTime() . "Calling GetNewestPackage function with the following arguments.\n");  
print LOGFILEHANDLE (getCurrentTime() . "packageType = $packageType, packageFileName = $packageFileName, newestSeqNum = $newestSeqNum.\n");        
# Get the newest unblessed definition package if there is any in the back office.
($status, $newerSequence) = SDGS::GetNewestPackage ($packageType, $packageFileName, $newestSeqNum);
#($status, $newerSequence) = SDGS1::GetNewestPackage ($packageType, $packageFileName, $newestSeqNum);
print "status = $status, newerSequence = $newerSequence\n";
print LOGFILEHANDLE (getCurrentTime() . "GetNewestPackage function returned: status = $status, newerSequence = $newerSequence.\n");        

# Define a local variable to store checksum.
my $checksum = "";

# Process the GetNewestPackage result only if the returned sequence number is
# greater than the newest sequence number already stored in the database.
if ($status == $SDGS::SDGS_OK && $newerSequence > $newestSeqNum) 
#if ($status == $SDGS1::SDGS_OK && $newerSequence > $newestSeqNum) 
  {
    # Unpack the imported newest unblessed definition package into a 
    # temporary directory.
    File::Basename::fileparse_set_fstype("MSDOS");
    my ($srcdir) = dirname(lc($packageFileName));
    my ($srcfilebase) = basename(lc($packageFileName),".$package_extension");
    # If it doesn't exist, create the target directory to unpack files.
    if (!(-d "$srcdir\\$srcfilebase"))
    {
        system ("mkdir $srcdir\\$srcfilebase");
    }
    print LOGFILEHANDLE (getCurrentTime() . "Calling BOSupport::unpack_package function with the following arguments.\n");        
    print LOGFILEHANDLE (getCurrentTime() . "packageFileName = $packageFileName, targetDir = $srcdir\\$srcfilebase.\n");        
    $status = BOSupport::unpack_package($packageFileName, "$srcdir\\$srcfilebase");
    print LOGFILEHANDLE (getCurrentTime() . "BOSupport::unpack_package function returned: status = $status.\n");        
    
    # Check the result of the unpacking.
    if ($status == $SDGS::SDGS_OK)
#    if ($status == $SDGS1::SDGS_OK)
      {
        # Form a 8 digit definition sequence number. 
        my $tempString = sprintf ("%08d", $newerSequence);
        my $targetDefPackageFileName = "$signatureStorageDirBase\\$tempString.$package_extension";
        # Migrate the imported newest unblessed package to the signature storage 
        # directory in the analysis center file server.
        print LOGFILEHANDLE (getCurrentTime() . "Calling BOSupport::migrate_package function with the following arguments.\n");        
        print LOGFILEHANDLE (getCurrentTime() . "packageFileName = $packageFileName, targetFile = $targetDefPackageFileName.\n");        
        my ($status,$destination) = BOSupport::migrate_package($packageFileName, $targetDefPackageFileName);
        print LOGFILEHANDLE (getCurrentTime() . "BOSupport::migrate_package function returned: status = $status, destination = $destination.\n");        
        
        # Check the result of the migrate package task.
        if ($status == $SDGS::SDGS_OK)
#        if ($status == $SDGS1::SDGS_OK)
          {
            # If the imported newest unblessed package has been imported
            # successfully, add a new signature record in the database. 
            # Calculate the md5 checksum of the resulting package.
            $checksum = ComputeMD5Checksum ($targetDefPackageFileName);
            
            # The 3rd argument of 0 tells the AddNewSig function that it is not a
            # blessed signature.
            print LOGFILEHANDLE (getCurrentTime() . "Calling AddNewSig function with the following arguments.\n");        
            print LOGFILEHANDLE (getCurrentTime() . "newerSequence = $newerSequence, checksum = $checksum, blessed = 0.\n");        
            AddNewSig ($newerSequence, $checksum, 0);
            $newestSeqNum = $newerSequence;
          }
      }            
  }
else
  {
    print LOGFILEHANDLE (getCurrentTime() . "Skipped calling BOSupport::unpack_package function.\n");        
  }

print LOGFILEHANDLE (getCurrentTime() . "Calling GetBlessedPackage function with the following arguments.\n");  
print LOGFILEHANDLE (getCurrentTime() . "packageType = $packageType, packageFileName = $packageFileName, newestBlssdSeqNum = $newestBlssdSeqNum.\n");        
# Get a new blessed definition package if there is any in the back office.
($status, $blessedSequence) = SDGS::GetBlessedPackage ($packageType, $packageFileName, $newestBlssdSeqNum);
#($status, $blessedSequence) = SDGS1::GetBlessedPackage ($packageType, $packageFileName, $newestBlssdSeqNum);
print "status = $status, blessedSequence = $blessedSequence\n";
print LOGFILEHANDLE (getCurrentTime() . "GetBlessedPackage function returned: status = $status, blessedSequence = $blessedSequence.\n");        

# Process the GetBlessedPackage result only if the returned sequence number is
# greater than the newest blessed sequence number already stored in the database.
if ($status == $SDGS::SDGS_OK && $blessedSequence > $newestBlssdSeqNum &&
#if ($status == $SDGS1::SDGS_OK && $blessedSequence > $newestBlssdSeqNum &&
    $blessedSequence <= $newestSeqNum) 
  {
    # Unpack the imported newest blessed definition package into a 
    # temporary directory.
    File::Basename::fileparse_set_fstype("MSDOS");
    my ($srcdir) = dirname(lc($packageFileName));
    my ($srcfilebase) = basename(lc($packageFileName),".$package_extension");
    # If it doesn't exist, create the target directory to unpack files.
    if (!(-d "$srcdir\\$srcfilebase"))
    {
        system ("mkdir $srcdir\\$srcfilebase");
    }
    print LOGFILEHANDLE (getCurrentTime() . "Calling BOSupport::unpack_package function with the following arguments.\n");        
    print LOGFILEHANDLE (getCurrentTime() . "packageFileName = $packageFileName, targetDir = $srcdir\\$srcfilebase.\n");        
    $status = BOSupport::unpack_package($packageFileName, "$srcdir\\$srcfilebase");
    print LOGFILEHANDLE (getCurrentTime() . "BOSupport::unpack_package function returned: status = $status.\n");        
    
    # Check the result of the unpacking.
    if ($status == $SDGS::SDGS_OK)
#    if ($status == $SDGS1::SDGS_OK)
      {
        # Form a 8 digit definition sequence number. 
        my $tempString = sprintf ("%08d", $blessedSequence);
        my $targetDefPackageFileName = "$signatureStorageDirBase\\$tempString.$package_extension";
        
        # If people in the back office blessed a package that we already have in the
        # analysis center, we need not copy the newly received package. However, it is
        # absolutely necessary to check if what we have already in the analysis center
        # and the one we received are exactly the same. We will do that by comparing
        # their md5 checksum. If there is a mismatch in checksum, we will notify the
        # back office via email and put the analysis center in CriticalError.
        if (-e $targetDefPackageFileName)
          {
            print LOGFILEHANDLE (getCurrentTime() . "Blessed target file $targetDefPackageFileName is already present in the analysis center.\n");        
            # Compute the md5 checksum for the one we already have in the analysis center.
            my $checksum1 = ComputeMD5Checksum ($targetDefPackageFileName);
            my $checksum2 = ComputeMD5Checksum ($packageFileName);
            print LOGFILEHANDLE (getCurrentTime() . "targetDefPackageFileName = $targetDefPackageFileName, checksum1 = $checksum1.\n");        
            print LOGFILEHANDLE (getCurrentTime() . "packageFileName = $packageFileName, checksum2 = $checksum2.\n");        
            
            if ($checksum1 ne $checksum2)
              {
                # There is a checksum mismatch in the package that is being claimed as
                # blessed by the back office. So set the system to CriticalError.
                $criticalError = 1;
                print LOGFILEHANDLE (getCurrentTime() . "Checksum mismatch. Setting CriticalError = $criticalError.\n");                              
              }
            else
              {
                $criticalError = 0;
                print LOGFILEHANDLE (getCurrentTime() . "Checksum matches. Setting CriticalError = $criticalError.\n");                              
              }
          }
        else
          {
            print LOGFILEHANDLE (getCurrentTime() . "Blessed target file $targetDefPackageFileName is not already present in the analysis center.\n");        
          }
        
        if ($criticalError == 0)
          {
            # If we are blessing an already existing definition sequence in the analysis center, there is no need
            # to copy the extracted files again. If you copy those files, it might cause file collisions with the
            # AVISDFRescan and the AVISFilter.
            if (-e $targetDefPackageFileName)
              {
                $status = $SDGS::SDGS_OK;
#                $status = $SDGS1::SDGS_OK;
              }
            else
              {
                # Migrate the imported blessed package to the signature storage 
                # directory in the analysis center file server.
                print LOGFILEHANDLE (getCurrentTime() . "Calling BOSupport::migrate_package function with the following arguments.\n");        
                print LOGFILEHANDLE (getCurrentTime() . "packageFileName = $packageFileName, targetFile = $targetDefPackageFileName.\n");        
                my ($status, $destination) = BOSupport::migrate_package($packageFileName, $targetDefPackageFileName);
                print LOGFILEHANDLE (getCurrentTime() . "BOSupport::migrate_package function returned: status = $status, destination = $destination.\n");        
              }
            
            if ($status == $SDGS::SDGS_OK)
#            if ($status == $SDGS1::SDGS_OK)
              {
                # If the imported newest blessed package has been imported
                # successfully, add a new signature record in the database. 
                # Calculate the md5 checksum of the resulting package.
                $checksum = ComputeMD5Checksum ($targetDefPackageFileName);
                
                # The 3rd argument of 1 tells the AddNewSig function that it is a
                # blessed signature.
                print LOGFILEHANDLE (getCurrentTime() . "Calling AddNewSig function with the following arguments.\n");        
                print LOGFILEHANDLE (getCurrentTime() . "blessedSequence = $blessedSequence, checksum = $checksum, blessed = 1.\n");        
                AddNewSig ($blessedSequence, $checksum, 1);
              }
          }  
      }                        
  }
else
  {
    print LOGFILEHANDLE (getCurrentTime() . "Skipped calling BOSupport::unpack_package function.\n");        
  }

############################################################
# DataFlow post processing
############################################################

# Initialize the NextService variable to empty string.
my $nextService = "";

# In case of critical error, set the NextService appropriately.
if ($criticalError == 1)
  {
    $nextService = "CriticalError";    
  }

# Form the parameter string with the unblessed and blessed sequence number.
my $parameter = "";
my $newerSequenceString = sprintf ("%08d", $newerSequence);
my $blessedSequenceString = sprintf ("%08d", $blessedSequence);
$parameter = "$newerSequenceString $blessedSequenceString";

print ("$Cookie, $ProcessID, $unc, $nextService, $parameter\n");
print ("$packageFileName, $signatureStorageDirBase\n");

print LOGFILEHANDLE (getCurrentTime() . "Calling BOSupport::dataflow_completion with the following arguments.\n"); 
print LOGFILEHANDLE (getCurrentTime() . "Cookie = $Cookie, ProcessID = $ProcessID, unc = $unc, nextService = $nextService, parameter = $parameter.\n"); 
# Call the DataFlow donwxt functions to write the result and stop files.
BOSupport::dataflow_completion($Cookie,
                               $ProcessID,
                               $unc,
                               $nextService,
                               $parameter,
                               "");


print LOGFILEHANDLE (getCurrentTime() . "BackOffice definition import activity has been completed.\n"); 
# Close the ODBC connection.
$db->Close ();
exit;

########################################################################
# This subroutine adds a new signature record in the database.
#
# Function arguments: 
#
# 1) Definition sequnece number to be added.
# 2) MD5 checksum value of the definition package file.
# 3) Blessed defintion or not.
#
# This function copies the blessed definition package if one is available
# into the given filename and returns the newest sequence number.
########################################################################
sub AddNewSig ($$)
  {
    my ($defSequence, $checksum, $blessed) = @_;
    ##########   BEGIN ADD NEW SIGNATURE RECORD ####################    
    print LOGFILEHANDLE (getCurrentTime() . "Creating and executing the SQL file for adding a new signature record.\n"); 
    
    # Form an SQL statement for adding the new defseqnumber into the Signatures table and execute the SQL statement.
    $sqlStatement = "INSERT INTO SIGNATURES VALUES ($defSequence, NULL, CURRENT TIMESTAMP, CURRENT TIMESTAMP, '$checksum')";
    $rc = $db->Sql ($sqlStatement);
    
    # Check for any SQL execution errors.
    if ($rc)
      {
        print LOGFILEHANDLE (getCurrentTime() . "Sql Failed. Error =" . $db->Error (). "\n");
        print LOGFILEHANDLE (getCurrentTime() . "Unable to add a new signature record in the database.\n"); 
      }
    else
      {
        print LOGFILEHANDLE (getCurrentTime() . "Added a new signature record in the database.\n"); 
      }
    ##########   END ADD NEW SIGNATURE RECORD ####################
    
    # If this is a blessed definition package, then set the blessed field of that
    # definition record in the Signatures table in the database.  
    if ($blessed == 1) 
      {
        ##########   BEGIN UPDATE BLESSED ATTRIBUTE IN THE SIGNATURE RECORD ####################                
        print LOGFILEHANDLE (getCurrentTime() . "Creating and executing the SQL file for updating the blessed date.\n"); 
        # Form an SQL statement for updating the BlessedDate entry in the Signatures table and execute the SQL statement.
        $sqlStatement = "UPDATE Signatures SET Blessed = CURRENT TIMESTAMP WHERE SignatureSeqNum = $defSequence";
        $rc = $db->Sql ($sqlStatement);
        
        # Check for any SQL execution errors.
        if ($rc)
          {
            print LOGFILEHANDLE (getCurrentTime() . "Sql Failed. Error =" . $db->Error (). "\n");
            print LOGFILEHANDLE (getCurrentTime() . "Unable to update the blessed date in the database.\n"); 
          }
        else
          {
            print LOGFILEHANDLE (getCurrentTime() . "Updated the blessed date in the database.\n"); 
          }     
        ##########   END UPDATE BLESSED ATTRIBUTE IN THE SIGNATURE RECORD ####################            
      }
    
    ##########   BEGIN ADD SIGSTOBEEXPORTED ENTRIES ####################
    print LOGFILEHANDLE (getCurrentTime() . "Creating and executing the SQL file for adding an entry in the SIGSTOBEEXPORTED table.\n"); 
    # Form an SQL statement for inserting entries into the SigsToBeExported table and execute the SQL statement.
    $sqlStatement = "INSERT INTO SIGSTOBEEXPORTED (ServerID, SignatureSeqNum) SELECT ServerID, $defSequence FROM Servers WHERE Active = 1";
    $rc = $db->Sql ($sqlStatement);
    
    # Check for any SQL execution errors.
    if ($rc)
      {
        print LOGFILEHANDLE (getCurrentTime() . "Sql Failed. Error =" . $db->Error (). "\n");
        print LOGFILEHANDLE (getCurrentTime() . "Unable to add an entry in the SIGSTOBEEXPORTED table.\n"); 
      }
    else
      {
        print LOGFILEHANDLE (getCurrentTime() . "Added an entry in the SIGSTOBEEXPORTED table.\n"); 
      }     
    ##########   END ADD SIGSTOBEEXPORTED ENTRIES ####################
  }


########################################################################
# This subroutine computes the MD5 checksum of a given file.
#
#
# Function arguments: 
#
# 1) Name of the file for which the MD5 checksum has to be computed.
#
# This function computes the MD5 checksum and returns it.
########################################################################
sub ComputeMD5Checksum ($)                        
  {
    # Parse the function argument. 
    my ($fileName) = @_;
    
    # If the file can't be opened, return now.
    unless (open FILEHANDLE, $fileName)
      {
        return ("WrongChecksum");
      }
    
    # Set binary mode for I/O operations.
    binmode (FILEHANDLE);
    # Seek to the beginning of the file.
    seek(FILEHANDLE, 0, 0);
    # Compute the MD5 checksum.
    my $md5 = new MD5;
    $md5->reset;
    $md5->add(<FILEHANDLE>);
    my $d = $md5->hexdigest;
    print "All lines at once = $d\n";
    
    # Close the file and return the computed checksum value. 
    close(FILEHANDLE);
    return ($d);
    
  }
                        
                        
                        ########################################################################
                        # This subroutine gets the current Date and Time and returns to 
                        # the caller
                        #
                        # Function arguments: 
                        #
                        # This function doesn't require any function arguments.
                        ########################################################################
                        sub getCurrentTime ()
{
    my ($sec, $min, $hr, $mday, $mon, $year, $wday, $yday, $isdst) = localtime (time);
    $year += 1900; #Y2K compliance 
    $mon++;
    return ("<$mon/$mday/$year $hr:$min:$sec> ");
}
