/*
 * FILE : nav_wrap.c
 * 
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Patch 5)
 * 
 * Portions Copyright (c) 1995-1998
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */


#define SWIGCODE
/* Implementation : PERL 5 */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#undef free
#undef malloc
#include <string.h>
#ifdef __cplusplus
}
#endif
/* Definitions for compiling Perl extensions on a variety of machines */

#if defined(WIN32) || defined(__WIN32__)
#   if defined(_MSC_VER)
#	define SWIGEXPORT(a,b) __declspec(dllexport) a b
#   else
#	if defined(__BORLANDC__)
#	    define SWIGEXPORT(a,b) a _export b
#	else
#	    define SWIGEXPORT(a,b) a b
#	endif
#   endif
#else
#   define SWIGEXPORT(a,b) a b
#endif

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerl *pPerl = (CPerl *) this;
#define MAGIC_CAST   (int (CPerl::*)(SV *, MAGIC *))
#define SWIGCLASS_STATIC 
#else
#define MAGIC_PPERL
#define MAGIC_CAST
#define SWIGCLASS_STATIC static
#endif


/*****************************************************************************
 * $Header: /home/beazley/SWIG/SWIG1.1b3/swig_lib/perl5/RCS/perl5ptr.swg,v 1.1 1996/12/26 22:17:29 beazley Exp beazley $
 *
 * perl5ptr.swg
 *
 * This file contains supporting code for the SWIG run-time type checking
 * mechanism.  The following functions are available :
 *
 * SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *));
 *
 *      Registers a new type-mapping with the type-checker.  origtype is the
 *      original datatype and newtype is an equivalent type.  cast is optional
 *      pointer to a function to cast pointer values between types (this
 *      is only used to cast pointers from derived classes to base classes in C++)
 *      
 * SWIG_MakePtr(char *buffer, void *ptr, char *typestring);
 *     
 *      Makes a pointer string from a pointer and typestring.  The result is returned
 *      in buffer.
 *
 * char * SWIG_GetPtr(SV *obj, void **ptr, char *type)
 *
 *      Gets a pointer value from a Perl5 scalar value.  If there is a 
 *      type-mismatch, returns a character string to the received type.  
 *      On success, returns NULL.
 *
 *
 * You can remap these functions by making a file called "swigptr.swg" in
 * your the same directory as the interface file you are wrapping.
 *
 * These functions are normally declared static, but this file can be
 * can be used in a multi-module environment by redefining the symbol
 * SWIGSTATIC.
 *
 * $Log: perl5ptr.swg,v $
 * Revision 1.1  1996/12/26 22:17:29  beazley
 * Initial revision
 *
 *****************************************************************************/

#include <stdlib.h>

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif

/* These are internal variables.   Should be static */

typedef struct SwigPtrType {
  char               *name;
  int                 len;
  void               *(*cast)(void *);
  struct SwigPtrType *next;
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */
static int SwigStart[256];             /* Table containing starting positions    */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

#ifndef PERL_OBJECT
SWIGSTATIC 
void SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {
#else
SWIGSTATIC
#define SWIG_RegisterMapping(a,b,c) _SWIG_RegisterMapping(pPerl, a,b,c)
void _SWIG_RegisterMapping(CPerl *pPerl, char *origtype, char *newtype, void *(*cast)(void *)) {
#endif

  int i;
  SwigPtrType *t = 0, *t1;

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc(SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }
  while (t->next) {
    if (strcmp(t->name,newtype) == 0) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;
  t->next = t1;
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATIC 
void SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Define for backwards compatibility */

#define _swig_make_hex   SWIG_MakePtr 

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGSTATIC 
char *SWIG_GetPtr(SV *sv, void **ptr, char *_t)
#else
SWIGSTATIC
#define SWIG_GetPtr(a,b,c) _SWIG_GetPtr(pPerl,a,b,c)
char *_SWIG_GetPtr(CPerl *pPerl, SV *sv, void **ptr, char *_t)
#endif
{
  char temp_type[256];
  char *name,*_c;
  int  len,i,start,end;
  IV   tmp;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;

  /* If magical, apply more magic */

  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
	mg = mg_find(tsv,'P');
	if (mg) {
	  SV *rsv = mg->mg_obj;
	  if (sv_isobject(rsv)) {
	    tmp = SvIV((SV*)SvRV(rsv));
	  }
	}
      } else {
	return "Not a valid pointer value";
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    if (!_t) {
      *(ptr) = (void *) tmp;
      return (char *) 0;
    }
  } else if (sv == &sv_undef) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return (char *) 0;
  } else if (SvTYPE(sv) == SVt_RV) {       /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return (char *) 0;
    else
      return "Not a valid pointer value";
  } else {                                 /* Don't know what it is */
      *(ptr) = (void *) 0;
      return "Not a valid pointer value";
  }
  if (_t) {
    /* Now see if the types match */      

    if (!sv_isa(sv,_t)) {
      _c = HvNAME(SvSTASH(SvRV(sv)));
      if (!SwigPtrSort) {
	qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort);  
	for (i = 0; i < 256; i++) {
	  SwigStart[i] = SwigPtrN;
	}
	for (i = SwigPtrN-1; i >= 0; i--) {
	  SwigStart[SwigPtrTable[i].name[0]] = i;
	}
	for (i = 255; i >= 1; i--) {
	  if (SwigStart[i-1] > SwigStart[i])
	    SwigStart[i-1] = SwigStart[i];
	}
	SwigPtrSort = 1;
	for (i = 0; i < SWIG_CACHESIZE; i++)  
	  SwigCache[i].stat = 0;
      }
      /* First check cache for matches.  Uses last cache value as starting point */
      cache = &SwigCache[SwigLastCache];
      for (i = 0; i < SWIG_CACHESIZE; i++) {
	if (cache->stat) {
	  if (strcmp(_t,cache->name) == 0) {
	    if (strcmp(_c,cache->mapped) == 0) {
	      cache->stat++;
	      *ptr = (void *) tmp;
	      if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
	      return (char *) 0;
	    }
	  }
	}
	SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	if (!SwigLastCache) cache = SwigCache;
	else cache++;
      }

      start = SwigStart[_t[0]];
      end = SwigStart[_t[0]+1];
      sp = &SwigPtrTable[start];
      while (start < end) {
	if (swigcmp(_t,sp) == 0) break;
	sp++;
	start++;
      }
      if (start >= end) sp = 0;
      if (sp) {
	while (swigcmp(_t,sp) == 0) {
	  name = sp->name;
	  len = sp->len;
	  tp = sp->next;
	  while(tp) {
	    if (tp->len >= 255) {
	      return _c;
	    }
	    strcpy(temp_type,tp->name);
	    strncat(temp_type,_t+len,255-tp->len);
	    if (sv_isa(sv,temp_type)) {
	      /* Get pointer value */
	      *ptr = (void *) tmp;
	      if (tp->cast) *ptr = (*(tp->cast))(*ptr);

	      strcpy(SwigCache[SwigCacheIndex].mapped,_c);
	      strcpy(SwigCache[SwigCacheIndex].name,_t);
	      SwigCache[SwigCacheIndex].stat = 1;
	      SwigCache[SwigCacheIndex].tp = tp;
	      SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
	      return (char *) 0;
	    }
	    tp = tp->next;
	  } 
	  /* Hmmm. Didn't find it this time */
 	  sp++;
	}
      }
      /* Didn't find any sort of match for this data.  
	 Get the pointer value and return the received type */
      *ptr = (void *) tmp;
      return _c;
    } else {
      /* Found a match on the first try.  Return pointer value */
      *ptr = (void *) tmp;
      return (char *) 0;
    }
  } 
  *ptr = (void *) tmp;
  return (char *) 0;
}

/* Compatibility mode */

#define _swig_get_hex  SWIG_GetPtr
/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) {
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerl *pPerl, SV *sv, char *name, int (CPerl::*set)(SV *, MAGIC *), int (CPerl::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = get;
  mg->mg_virtual->svt_set = set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}

#define SWIG_init    boot_navapi

#define SWIG_name   "navapi::boot_navapi"
#define SWIG_varinit "navapi::var_navapi_init();"
#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
SWIGEXPORT(void,boot_navapi)(CV* cv);
#else
SWIGEXPORT(void,boot_navapi)(CPerl *, CV *cv);
#endif

#include "navapi.h"
#ifndef PERL_OBJECT
#define swig_setiv(a,b) _swig_setiv(a,b)
static void _swig_setiv(char *name, long value) { 
#else
#define swig_setiv(a,b) _swig_setiv(pPerl,a,b)
static void _swig_setiv(CPerl *pPerl, char *name, long value) { 
#endif
     SV *sv; 
     sv = perl_get_sv(name,TRUE | 0x2);
     sv_setiv(sv, (IV) value);
     SvREADONLY_on(sv);
}

extern LPNAVFILEIO CallBackInit();
#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_navapi_var::
class _wrap_navapi_var : public CPerl {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}


#ifdef PERL_OBJECT
};
#endif

XS(_wrap_NAVEngineInit) {

    HNAVENGINE  _result;
    LPTSTR  _arg0;
    LPTSTR  _arg1;
    LPNAVFILEIO  _arg2;
    unsigned short  _arg3;
    unsigned short  _arg4;
    NAVSTATUS * _arg5;
    NAVSTATUS  temp;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
	temp=0;
	_arg5=&temp;
}
    if ((items < 5) || (items > 5)) 
        croak("Usage: NAVEngineInit(lpszDefsPath,lpszNavexInfFile,lpFileCallbacks,wHeuristicLevel,wFlags);");
    _arg0 = (char *) SvPV(ST(0),na);
    _arg1 = (char *) SvPV(ST(1),na);
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"LPNAVFILEIO")) {
        croak("Type error in argument 3 of NAVEngineInit. Expected LPNAVFILEIO.");
        XSRETURN(1);
    }
    _arg3 = (unsigned short )SvIV(ST(3));
    _arg4 = (unsigned short )SvIV(ST(4));
    _result = (HNAVENGINE )NAVEngineInit(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"HNAVENGINE", (void *) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setiv(ST(argvi),(IV) *(_arg5));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_NAVEngineClose) {

    NAVSTATUS  _result;
    HNAVENGINE  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: NAVEngineClose(hNAVEngine);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVENGINE")) {
        croak("Type error in argument 1 of NAVEngineClose. Expected HNAVENGINE.");
        XSRETURN(1);
    }
    _result = (NAVSTATUS )NAVEngineClose(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_NAVScanFile) {

    NAVSTATUS  _result;
    HNAVENGINE  _arg0;
    LPVOID  _arg1;
    LPTSTR  _arg2;
    BOOL  _arg3;
    HNAVVIRUS * _arg4;
    HNAVVIRUS  temp;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
	_arg4=&temp;
}
    if ((items < 4) || (items > 4)) 
        croak("Usage: NAVScanFile(hNAVEngine,lpFileId,lpstFileExt,bPreserveLastAccess);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVENGINE")) {
        croak("Type error in argument 1 of NAVScanFile. Expected HNAVENGINE.");
        XSRETURN(1);
    }
{
  _arg1 = (char *) SvPV(ST(1),na);
}
    _arg2 = (char *) SvPV(ST(2),na);
    _arg3 = (BOOL )SvIV(ST(3));
    _result = (NAVSTATUS )NAVScanFile(_arg0,_arg1,_arg2,_arg3,_arg4);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setref_pv(ST(argvi),"HNAVVIRUS", (void *) (*_arg4));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_NAVScanBoot) {

    NAVSTATUS  _result;
    HNAVENGINE  _arg0;
    char  _arg1;
    HNAVVIRUS * _arg2;
    HNAVVIRUS  temp;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
	_arg2=&temp;
}
    if ((items < 2) || (items > 2)) 
        croak("Usage: NAVScanBoot(hNAVEngine,cDriveLetter);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVENGINE")) {
        croak("Type error in argument 1 of NAVScanBoot. Expected HNAVENGINE.");
        XSRETURN(1);
    }
    _arg1 = (char) *SvPV(ST(1),na);
    _result = (NAVSTATUS )NAVScanBoot(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setref_pv(ST(argvi),"HNAVVIRUS", (void *) (*_arg2));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_NAVScanMasterBoot) {

    NAVSTATUS  _result;
    HNAVENGINE  _arg0;
    unsigned int  _arg1;
    HNAVVIRUS * _arg2;
    HNAVVIRUS  temp;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
	_arg2=&temp;
}
    if ((items < 2) || (items > 2)) 
        croak("Usage: NAVScanMasterBoot(hNAVEngine,uPhysDriveNum);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVENGINE")) {
        croak("Type error in argument 1 of NAVScanMasterBoot. Expected HNAVENGINE.");
        XSRETURN(1);
    }
    _arg1 = (unsigned int )SvIV(ST(1));
    _result = (NAVSTATUS )NAVScanMasterBoot(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setref_pv(ST(argvi),"HNAVVIRUS", (void *) (*_arg2));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_NAVScanMemory) {

    NAVSTATUS  _result;
    HNAVENGINE  _arg0;
    HNAVVIRUS * _arg1;
    HNAVVIRUS  temp;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
	_arg1=&temp;
}
    if ((items < 1) || (items > 1)) 
        croak("Usage: NAVScanMemory(hNAVEngine);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVENGINE")) {
        croak("Type error in argument 1 of NAVScanMemory. Expected HNAVENGINE.");
        XSRETURN(1);
    }
    _result = (NAVSTATUS )NAVScanMemory(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setref_pv(ST(argvi),"HNAVVIRUS", (void *) (*_arg1));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_NAVRepairFile) {

    NAVSTATUS  _result;
    HNAVENGINE  _arg0;
    LPVOID  _arg1;
    LPTSTR  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: NAVRepairFile(hNAVEngine,lpFileId,lpstFileExt);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVENGINE")) {
        croak("Type error in argument 1 of NAVRepairFile. Expected HNAVENGINE.");
        XSRETURN(1);
    }
{
  _arg1 = (char *) SvPV(ST(1),na);
}
    _arg2 = (char *) SvPV(ST(2),na);
    _result = (NAVSTATUS )NAVRepairFile(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_NAVDeleteFile) {

    NAVSTATUS  _result;
    HNAVENGINE  _arg0;
    LPVOID  _arg1;
    LPTSTR  _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: NAVDeleteFile(hNAVEngine,lpFileId,lpstFileExt);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVENGINE")) {
        croak("Type error in argument 1 of NAVDeleteFile. Expected HNAVENGINE.");
        XSRETURN(1);
    }
{
  _arg1 = (char *) SvPV(ST(1),na);
}
    _arg2 = (char *) SvPV(ST(2),na);
    _result = (NAVSTATUS )NAVDeleteFile(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_NAVRepairBoot) {

    NAVSTATUS  _result;
    HNAVENGINE  _arg0;
    char  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: NAVRepairBoot(hNAVEngine,cDriveLetter);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVENGINE")) {
        croak("Type error in argument 1 of NAVRepairBoot. Expected HNAVENGINE.");
        XSRETURN(1);
    }
    _arg1 = (char) *SvPV(ST(1),na);
    _result = (NAVSTATUS )NAVRepairBoot(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_NAVRepairMasterBoot) {

    NAVSTATUS  _result;
    HNAVENGINE  _arg0;
    unsigned int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: NAVRepairMasterBoot(hNAVEngine,uPhysDriveNum);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVENGINE")) {
        croak("Type error in argument 1 of NAVRepairMasterBoot. Expected HNAVENGINE.");
        XSRETURN(1);
    }
    _arg1 = (unsigned int )SvIV(ST(1));
    _result = (NAVSTATUS )NAVRepairMasterBoot(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_NAVFreeVirusHandle) {

    NAVSTATUS  _result;
    HNAVVIRUS  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: NAVFreeVirusHandle(hVirus);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVVIRUS")) {
        croak("Type error in argument 1 of NAVFreeVirusHandle. Expected HNAVVIRUS.");
        XSRETURN(1);
    }
    _result = (NAVSTATUS )NAVFreeVirusHandle(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_NAVGetVirusInfo) {

    DWORD  _result;
    HNAVVIRUS  _arg0;
    NAVVIRINFO  _arg1;
    LPTSTR  _arg2;
    char * temp;
    LPDWORD  _arg3;
    int argvi = 0;
    unsigned long  temp0;
    SV * _saved[1];
    dXSARGS ;

    cv = cv;
{
	temp="";
	_arg2=temp;
}
    if ((items < 3) || (items > 3)) 
        croak("Usage: NAVGetVirusInfo(hNAVVirus,enumVirInfo,lpdwBufferSize);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVVIRUS")) {
        croak("Type error in argument 1 of NAVGetVirusInfo. Expected HNAVVIRUS.");
        XSRETURN(1);
    }
    _arg1 = (NAVVIRINFO )SvIV(ST(1));
{
  temp0 = (unsigned long) SvIV(ST(2));
  _arg3 = &temp0;
}
    _saved[0] = ST(2);
    _result = (DWORD )NAVGetVirusInfo(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setpv((SV*)ST(argvi),(char *)_arg2);
  argvi++;
}
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setiv(ST(argvi),(IV) *(_arg3));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_NAVGetVirusDefCount) {

    NAVSTATUS  _result;
    HNAVENGINE  _arg0;
    DWORD * _arg1;
    unsigned long  temp;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
	temp=0;
	_arg1=&temp;
}
    if ((items < 1) || (items > 1)) 
        croak("Usage: NAVGetVirusDefCount(hNAVEngine);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVENGINE")) {
        croak("Type error in argument 1 of NAVGetVirusDefCount. Expected HNAVENGINE.");
        XSRETURN(1);
    }
    _result = (NAVSTATUS )NAVGetVirusDefCount(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setiv(ST(argvi),(IV) *(_arg1));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_NAVLoadVirusDef) {

    HNAVVIRUSDEF  _result;
    HNAVENGINE  _arg0;
    DWORD  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: NAVLoadVirusDef(hNAVEngine,dwDefIndex);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVENGINE")) {
        croak("Type error in argument 1 of NAVLoadVirusDef. Expected HNAVENGINE.");
        XSRETURN(1);
    }
    _arg1 = (DWORD )SvIV(ST(1));
    _result = (HNAVVIRUSDEF )NAVLoadVirusDef(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"HNAVVIRUSDEF", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_NAVReleaseVirusDef) {

    HNAVVIRUSDEF  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: NAVReleaseVirusDef(hNAVVirusDef);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVVIRUSDEF")) {
        croak("Type error in argument 1 of NAVReleaseVirusDef. Expected HNAVVIRUSDEF.");
        XSRETURN(1);
    }
    NAVReleaseVirusDef(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_NAVGetVirusDefInfo) {

    DWORD  _result;
    HNAVVIRUSDEF  _arg0;
    NAVVIRINFO  _arg1;
    LPTSTR  _arg2;
    char * temp;
    LPDWORD  _arg3;
    int argvi = 0;
    unsigned long  temp0;
    SV * _saved[1];
    dXSARGS ;

    cv = cv;
{
	temp="";
	_arg2=temp;
}
    if ((items < 3) || (items > 3)) 
        croak("Usage: NAVGetVirusDefInfo(hNAVVirusDef,enumVirInfo,lpdwBufferSize);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVVIRUSDEF")) {
        croak("Type error in argument 1 of NAVGetVirusDefInfo. Expected HNAVVIRUSDEF.");
        XSRETURN(1);
    }
    _arg1 = (NAVVIRINFO )SvIV(ST(1));
{
  temp0 = (unsigned long) SvIV(ST(2));
  _arg3 = &temp0;
}
    _saved[0] = ST(2);
    _result = (DWORD )NAVGetVirusDefInfo(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setpv((SV*)ST(argvi),(char *)_arg2);
  argvi++;
}
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setiv(ST(argvi),(IV) *(_arg3));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_NAVLoadVirusDefTable) {

    HNAVVIRUSDEFTABLE  _result;
    HNAVENGINE  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: NAVLoadVirusDefTable(hNAVEngine);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVENGINE")) {
        croak("Type error in argument 1 of NAVLoadVirusDefTable. Expected HNAVENGINE.");
        XSRETURN(1);
    }
    _result = (HNAVVIRUSDEFTABLE )NAVLoadVirusDefTable(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"HNAVVIRUSDEFTABLE", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_NAVReleaseVirusDefTable) {

    HNAVVIRUSDEFTABLE  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: NAVReleaseVirusDefTable(hNAVVirusDefTable);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVVIRUSDEFTABLE")) {
        croak("Type error in argument 1 of NAVReleaseVirusDefTable. Expected HNAVVIRUSDEFTABLE.");
        XSRETURN(1);
    }
    NAVReleaseVirusDefTable(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_NAVGetVirusDefTableCount) {

    NAVSTATUS  _result;
    HNAVVIRUSDEFTABLE  _arg0;
    DWORD * _arg1;
    unsigned long  temp;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
	temp=0;
	_arg1=&temp;
}
    if ((items < 1) || (items > 1)) 
        croak("Usage: NAVGetVirusDefTableCount(hNAVVirusDefTable);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVVIRUSDEFTABLE")) {
        croak("Type error in argument 1 of NAVGetVirusDefTableCount. Expected HNAVVIRUSDEFTABLE.");
        XSRETURN(1);
    }
    _result = (NAVSTATUS )NAVGetVirusDefTableCount(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setiv(ST(argvi),(IV) *(_arg1));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_NAVGetVirusDefTableInfo) {

    DWORD  _result;
    HNAVVIRUSDEFTABLE  _arg0;
    DWORD  _arg1;
    NAVVIRINFO  _arg2;
    LPTSTR  _arg3;
    char * temp;
    LPDWORD  _arg4;
    int argvi = 0;
    unsigned long  temp0;
    SV * _saved[1];
    dXSARGS ;

    cv = cv;
{
	temp="";
	_arg3=temp;
}
    if ((items < 4) || (items > 4)) 
        croak("Usage: NAVGetVirusDefTableInfo(hNAVVirusDefTable,dwIndex,enumVirInfo,lpdwBufferSize);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVVIRUSDEFTABLE")) {
        croak("Type error in argument 1 of NAVGetVirusDefTableInfo. Expected HNAVVIRUSDEFTABLE.");
        XSRETURN(1);
    }
    _arg1 = (DWORD )SvIV(ST(1));
    _arg2 = (NAVVIRINFO )SvIV(ST(2));
{
  temp0 = (unsigned long) SvIV(ST(3));
  _arg4 = &temp0;
}
    _saved[0] = ST(3);
    _result = (DWORD )NAVGetVirusDefTableInfo(_arg0,_arg1,_arg2,_arg3,_arg4);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setpv((SV*)ST(argvi),(char *)_arg3);
  argvi++;
}
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setiv(ST(argvi),(IV) *(_arg4));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_NAVGetNavapiVersionString) {

    NAVSTATUS  _result;
    LPTSTR  _arg0;
    char * temp;
    unsigned int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
	temp="";
	_arg0=temp;
}
    if ((items < 1) || (items > 1)) 
        croak("Usage: NAVGetNavapiVersionString(uBufferSize);");
    _arg1 = (unsigned int )SvIV(ST(0));
    _result = (NAVSTATUS )NAVGetNavapiVersionString(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setpv((SV*)ST(argvi),(char *)_arg0);
  argvi++;
}
    XSRETURN(argvi);
}
VIRUSDBINFO Mytemp;
XS(_wrap_NAVGetVirusDBInfo) {

    NAVSTATUS  _result;
    HNAVENGINE  _arg0;
    LPVIRUSDBINFO  _arg1;
    LPVIRUSDBINFO  temp;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
{
	_arg1=&Mytemp;
}
    if ((items < 1) || (items > 1)) 
        croak("Usage: NAVGetVirusDBInfo(hNAVEngine);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"HNAVENGINE")) {
        croak("Type error in argument 1 of NAVGetVirusDBInfo. Expected HNAVENGINE.");
        XSRETURN(1);
    }
    _result = (NAVSTATUS )NAVGetVirusDBInfo(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
{
  if (argvi >= items) {
    EXTEND(sp,1);
  }
  ST(argvi) = sv_newmortal();
  sv_setref_pv(ST(argvi),"LPVIRUSDBINFO", (void *)_arg1);
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_CallBackInit) {

    LPNAVFILEIO  _result;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: CallBackInit();");
    _result = (LPNAVFILEIO )CallBackInit();
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"LPNAVFILEIO", (void *) _result);
    XSRETURN(argvi);
}
//My CallBacks

DWORD MyOpen (LPVOID lpvFileInfo, DWORD dwOpenMode)
{
	HFILE hFile;
	OFSTRUCT sOF;
	hFile=OpenFile ((char *)lpvFileInfo,&sOF,(unsigned int)(dwOpenMode));
	return((DWORD)(hFile));
}
BOOL MyClose (DWORD dwHandle)
{
	return((BOOL)(!_lclose((HFILE)(dwHandle))));
}

DWORD MySeek (DWORD  dwHandle, LONG lOffset, int nFrom )
{
	 return((DWORD)(_llseek((HFILE)(dwHandle),
                   lOffset,
                   nFrom)));
}

UINT MyRead (DWORD dwHandle, LPVOID lpvBuffer, UINT uBytesToRead)
{
	return(_lread((HFILE)(dwHandle),lpvBuffer,uBytesToRead));
}

UINT  MyWrite  ( DWORD  dwHandle, LPVOID lpvBuffer, UINT uBytesToWrite )
{
	return(_lwrite((HFILE)(dwHandle),(char *)lpvBuffer,uBytesToWrite));

}
BOOL MyDelete ( LPVOID lpvFileInfo )
{
	return(DeleteFile((char *)lpvFileInfo));
}

BOOL  MyGetDateTime ( DWORD dwHandle, UINT uType, LPWORD lpwDate, LPWORD lpwTime )
{
	FILETIME CreationTime,LastAccessTime,LastWriteTime;
	if (GetFileTime((HANDLE)(dwHandle), &CreationTime, &LastAccessTime, &LastWriteTime))
	{
		switch(uType)
		{
		case NAV_TIME_LASTWRITE :
			return(FileTimeToDosDateTime(&LastWriteTime,lpwDate,lpwTime));
			break;

		case NAV_TIME_LASTACCESS :
			return(FileTimeToDosDateTime(&LastAccessTime,lpwDate,lpwTime));
			break;

		case NAV_TIME_CREATION :
			return(FileTimeToDosDateTime(&CreationTime,lpwDate,lpwTime));
			break;

		default :
			return(0);
			break;
		}
	}
	else
		return(0);
}

BOOL  MySetDateTime ( DWORD dwHandle, UINT uType, unsigned short wDate, unsigned short wTime )
{
	FILETIME fTime;
	
	switch(uType)
		{
		case NAV_TIME_LASTWRITE :
			if(DosDateTimeToFileTime(wDate,wTime,&fTime))
				return(SetFileTime((HANDLE)(dwHandle), NULL, NULL, &fTime));
			else
				return(0);
			break;

		case NAV_TIME_LASTACCESS :
			if(DosDateTimeToFileTime(wDate,wTime,&fTime))
				return(SetFileTime((HANDLE)(dwHandle), NULL, &fTime, NULL));
			else
				return(0);
			break;

		case NAV_TIME_CREATION :
			if(DosDateTimeToFileTime(wDate,wTime,&fTime))
				return(SetFileTime((HANDLE)(dwHandle), &fTime, NULL, NULL));
			else
				return(0);
			break;

		default :
			return(0);
			break;
		}
}

LPNAVFILEIO CallBackInit()
{
	LPNAVFILEIO CallBackInitIO;
	CallBackInitIO=(LPNAVFILEIO)malloc(sizeof(NAVFILEIO));
	CallBackInitIO->Open=&MyOpen;
	CallBackInitIO->Close=&MyClose;
	CallBackInitIO->Seek=&MySeek;
	CallBackInitIO->Read=&MyRead;
	CallBackInitIO->Write=&MyWrite;
	CallBackInitIO->Delete=&MyDelete;
	CallBackInitIO->GetDateTime=&MyGetDateTime;
	CallBackInitIO->SetDateTime=&MySetDateTime;
	return (CallBackInitIO);
}
//End My CallBacks.
#define tagVIRUSDBINFO_dwVersion_set(_swigobj,_swigval) (_swigobj->dwVersion = _swigval,_swigval)
XS(_wrap_VIRUSDBINFO_dwVersion_set) {

    DWORD  _result;
    VIRUSDBINFO * _arg0;
    DWORD  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: VIRUSDBINFO_dwVersion_set(VIRUSDBINFO *,DWORD );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"VIRUSDBINFOPtr")) {
        croak("Type error in argument 1 of VIRUSDBINFO_dwVersion_set. Expected VIRUSDBINFOPtr.");
        XSRETURN(1);
    }
    _arg1 = (DWORD )SvIV(ST(1));
    _result = (DWORD )tagVIRUSDBINFO_dwVersion_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define tagVIRUSDBINFO_dwVersion_get(_swigobj) ((DWORD ) _swigobj->dwVersion)
XS(_wrap_VIRUSDBINFO_dwVersion_get) {

    DWORD  _result;
    VIRUSDBINFO * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: VIRUSDBINFO_dwVersion_get(VIRUSDBINFO *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"VIRUSDBINFOPtr")) {
        croak("Type error in argument 1 of VIRUSDBINFO_dwVersion_get. Expected VIRUSDBINFOPtr.");
        XSRETURN(1);
    }
    _result = (DWORD )tagVIRUSDBINFO_dwVersion_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define tagVIRUSDBINFO_wDay_set(_swigobj,_swigval) (_swigobj->wDay = _swigval,_swigval)
XS(_wrap_VIRUSDBINFO_wDay_set) {

    unsigned short  _result;
    VIRUSDBINFO * _arg0;
    unsigned short  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: VIRUSDBINFO_wDay_set(VIRUSDBINFO *,unsigned short );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"VIRUSDBINFOPtr")) {
        croak("Type error in argument 1 of VIRUSDBINFO_wDay_set. Expected VIRUSDBINFOPtr.");
        XSRETURN(1);
    }
    _arg1 = (unsigned short )SvIV(ST(1));
    _result = (unsigned short )tagVIRUSDBINFO_wDay_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define tagVIRUSDBINFO_wDay_get(_swigobj) ((unsigned short ) _swigobj->wDay)
XS(_wrap_VIRUSDBINFO_wDay_get) {

    unsigned short  _result;
    VIRUSDBINFO * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: VIRUSDBINFO_wDay_get(VIRUSDBINFO *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"VIRUSDBINFOPtr")) {
        croak("Type error in argument 1 of VIRUSDBINFO_wDay_get. Expected VIRUSDBINFOPtr.");
        XSRETURN(1);
    }
    _result = (unsigned short )tagVIRUSDBINFO_wDay_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define tagVIRUSDBINFO_wMonth_set(_swigobj,_swigval) (_swigobj->wMonth = _swigval,_swigval)
XS(_wrap_VIRUSDBINFO_wMonth_set) {

    unsigned short  _result;
    VIRUSDBINFO * _arg0;
    unsigned short  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: VIRUSDBINFO_wMonth_set(VIRUSDBINFO *,unsigned short );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"VIRUSDBINFOPtr")) {
        croak("Type error in argument 1 of VIRUSDBINFO_wMonth_set. Expected VIRUSDBINFOPtr.");
        XSRETURN(1);
    }
    _arg1 = (unsigned short )SvIV(ST(1));
    _result = (unsigned short )tagVIRUSDBINFO_wMonth_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define tagVIRUSDBINFO_wMonth_get(_swigobj) ((unsigned short ) _swigobj->wMonth)
XS(_wrap_VIRUSDBINFO_wMonth_get) {

    unsigned short  _result;
    VIRUSDBINFO * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: VIRUSDBINFO_wMonth_get(VIRUSDBINFO *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"VIRUSDBINFOPtr")) {
        croak("Type error in argument 1 of VIRUSDBINFO_wMonth_get. Expected VIRUSDBINFOPtr.");
        XSRETURN(1);
    }
    _result = (unsigned short )tagVIRUSDBINFO_wMonth_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define tagVIRUSDBINFO_wYear_set(_swigobj,_swigval) (_swigobj->wYear = _swigval,_swigval)
XS(_wrap_VIRUSDBINFO_wYear_set) {

    unsigned short  _result;
    VIRUSDBINFO * _arg0;
    unsigned short  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: VIRUSDBINFO_wYear_set(VIRUSDBINFO *,unsigned short );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"VIRUSDBINFOPtr")) {
        croak("Type error in argument 1 of VIRUSDBINFO_wYear_set. Expected VIRUSDBINFOPtr.");
        XSRETURN(1);
    }
    _arg1 = (unsigned short )SvIV(ST(1));
    _result = (unsigned short )tagVIRUSDBINFO_wYear_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define tagVIRUSDBINFO_wYear_get(_swigobj) ((unsigned short ) _swigobj->wYear)
XS(_wrap_VIRUSDBINFO_wYear_get) {

    unsigned short  _result;
    VIRUSDBINFO * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: VIRUSDBINFO_wYear_get(VIRUSDBINFO *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"VIRUSDBINFOPtr")) {
        croak("Type error in argument 1 of VIRUSDBINFO_wYear_get. Expected VIRUSDBINFOPtr.");
        XSRETURN(1);
    }
    _result = (unsigned short )tagVIRUSDBINFO_wYear_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_perl5_navapi_var_init) {
    dXSARGS;
    SV *sv;
    cv = cv; items = items;
    swig_setiv("NAV_OK", (long) 0);
    swig_setiv("NAV_ERROR", (long) 1);
    swig_setiv("NAV_INSUFFICIENT_BUFFER", (long) 2);
    swig_setiv("NAV_INVALID_ARG", (long) 3);
    swig_setiv("NAV_MEMORY_ERROR", (long) 4);
    swig_setiv("NAV_NO_ACCESS", (long) 5);
    swig_setiv("NAV_CANT_REPAIR", (long) 6);
    swig_setiv("NAV_CANT_DELETE", (long) 7);
    swig_setiv("NAV_ENGINE_IN_USE", (long) 8);
    swig_setiv("NAV_VXD_INIT_FAILURE", (long) 9);
    swig_setiv("NAV_DEFINITIONS_ERROR", (long) 10);
    swig_setiv("NAV_VI_VIRUS_NAME", (long) NAV_VI_VIRUS_NAME);
    swig_setiv("NAV_VI_VIRUS_ALIAS", (long) NAV_VI_VIRUS_ALIAS);
    swig_setiv("NAV_VI_VIRUS_INFO", (long) NAV_VI_VIRUS_INFO);
    swig_setiv("NAV_VI_VIRUS_SIZE", (long) NAV_VI_VIRUS_SIZE);
    swig_setiv("NAV_VI_BOOL_INFECT_FILES", (long) NAV_VI_BOOL_INFECT_FILES);
    swig_setiv("NAV_VI_BOOL_INFECT_EXE", (long) NAV_VI_BOOL_INFECT_EXE);
    swig_setiv("NAV_VI_BOOL_INFECT_COM", (long) NAV_VI_BOOL_INFECT_COM);
    swig_setiv("NAV_VI_BOOL_INFECT_COMCOM", (long) NAV_VI_BOOL_INFECT_COMCOM);
    swig_setiv("NAV_VI_BOOL_INFECT_SYS", (long) NAV_VI_BOOL_INFECT_SYS);
    swig_setiv("NAV_VI_BOOL_INFECT_MBR", (long) NAV_VI_BOOL_INFECT_MBR);
    swig_setiv("NAV_VI_BOOL_INFECT_FLOPPY_BOOT", (long) NAV_VI_BOOL_INFECT_FLOPPY_BOOT);
    swig_setiv("NAV_VI_BOOL_INFECT_HD_BOOT", (long) NAV_VI_BOOL_INFECT_HD_BOOT);
    swig_setiv("NAV_VI_BOOL_INFECT_WILD", (long) NAV_VI_BOOL_INFECT_WILD);
    swig_setiv("NAV_VI_BOOL_MEMORY_RES", (long) NAV_VI_BOOL_MEMORY_RES);
    swig_setiv("NAV_VI_BOOL_SIZE_STEALTH", (long) NAV_VI_BOOL_SIZE_STEALTH);
    swig_setiv("NAV_VI_BOOL_FULL_STEALTH", (long) NAV_VI_BOOL_FULL_STEALTH);
    swig_setiv("NAV_VI_BOOL_TRIGGER", (long) NAV_VI_BOOL_TRIGGER);
    swig_setiv("NAV_VI_BOOL_ENCRYPTING", (long) NAV_VI_BOOL_ENCRYPTING);
    swig_setiv("NAV_VI_BOOL_POLYMORPHIC", (long) NAV_VI_BOOL_POLYMORPHIC);
    swig_setiv("NAV_VI_BOOL_MULTIPART", (long) NAV_VI_BOOL_MULTIPART);
    swig_setiv("NAV_VI_BOOL_MAC_VIRUS", (long) NAV_VI_BOOL_MAC_VIRUS);
    swig_setiv("NAV_VI_BOOL_MACRO_VIRUS", (long) NAV_VI_BOOL_MACRO_VIRUS);
    swig_setiv("NAV_VI_BOOL_WINDOWS_VIRUS", (long) NAV_VI_BOOL_WINDOWS_VIRUS);
    swig_setiv("NAV_VI_BOOL_AGENT_VIRUS", (long) NAV_VI_BOOL_AGENT_VIRUS);
    swig_setiv("NAV_VI_BOOL_REPAIRED", (long) NAV_VI_BOOL_REPAIRED);
    swig_setiv("NAV_VI_BOOL_REPAIR_FAILED", (long) NAV_VI_BOOL_REPAIR_FAILED);
    swig_setiv("NAV_VI_BOOL_REPAIRABLE", (long) NAV_VI_BOOL_REPAIRABLE);
    swig_setiv("NAV_VI_BOOL_DELETABLE", (long) NAV_VI_BOOL_DELETABLE);
    swig_setiv("NAV_VI_BOOL_NO_ACCESS", (long) NAV_VI_BOOL_NO_ACCESS);
    swig_setiv("NAV_VI_BOOL_DISEMBODIED", (long) NAV_VI_BOOL_DISEMBODIED);
    swig_setiv("NAV_VI_BOOL_DELETED", (long) NAV_VI_BOOL_DELETED);
    swig_setiv("NAV_VI_BOOL_DELETE_FAILED", (long) NAV_VI_BOOL_DELETE_FAILED);
    swig_setiv("NAV_VI_BOOL_DEF_DELETED", (long) NAV_VI_BOOL_DEF_DELETED);
    swig_setiv("NAV_VI_BOOL_INFO_VALID", (long) NAV_VI_BOOL_INFO_VALID);
    swig_setiv("NAV_VI_BOOL_MEMORY_DETECT", (long) NAV_VI_BOOL_MEMORY_DETECT);
    swig_setiv("NAV_VI_BOOL_FILE_ITEM", (long) NAV_VI_BOOL_FILE_ITEM);
    swig_setiv("NAV_VI_BOOL_BOOT_ITEM", (long) NAV_VI_BOOL_BOOT_ITEM);
    swig_setiv("NAV_VI_BOOL_PART_ITEM", (long) NAV_VI_BOOL_PART_ITEM);
    swig_setiv("NAV_VI_ITEM_NAME", (long) NAV_VI_ITEM_NAME);
    swig_setiv("NAV_VI_DETECT_DATE", (long) NAV_VI_DETECT_DATE);
    swig_setiv("NAV_VI_DETECT_TIME", (long) NAV_VI_DETECT_TIME);
    swig_setiv("NAV_VI_PHYSICAL_DRIVE_NUM", (long) NAV_VI_PHYSICAL_DRIVE_NUM);
    swig_setiv("NAV_VI_PARTITION_NUM", (long) NAV_VI_PARTITION_NUM);
    swig_setiv("NAV_VI_PARTITION_TYPE", (long) NAV_VI_PARTITION_TYPE);
    swig_setiv("NAV_VI_VIRUS_ID", (long) NAV_VI_VIRUS_ID);
    swig_setiv("NAV_TIME_LASTWRITE", (long) 0);
    swig_setiv("NAV_TIME_LASTACCESS", (long) 4);
    swig_setiv("NAV_TIME_CREATION", (long) 6);
    XSRETURN(1);
}
#ifdef __cplusplus
extern "C"
#endif
XS(boot_navapi) {
	 dXSARGS;
	 char *file = __FILE__;
	 cv = cv; items = items;
	 newXS("navapi::var_navapi_init", _wrap_perl5_navapi_var_init, file);
	 newXS("navapi::NAVEngineInit", _wrap_NAVEngineInit, file);
	 newXS("navapi::NAVEngineClose", _wrap_NAVEngineClose, file);
	 newXS("navapi::NAVScanFile", _wrap_NAVScanFile, file);
	 newXS("navapi::NAVScanBoot", _wrap_NAVScanBoot, file);
	 newXS("navapi::NAVScanMasterBoot", _wrap_NAVScanMasterBoot, file);
	 newXS("navapi::NAVScanMemory", _wrap_NAVScanMemory, file);
	 newXS("navapi::NAVRepairFile", _wrap_NAVRepairFile, file);
	 newXS("navapi::NAVDeleteFile", _wrap_NAVDeleteFile, file);
	 newXS("navapi::NAVRepairBoot", _wrap_NAVRepairBoot, file);
	 newXS("navapi::NAVRepairMasterBoot", _wrap_NAVRepairMasterBoot, file);
	 newXS("navapi::NAVFreeVirusHandle", _wrap_NAVFreeVirusHandle, file);
	 newXS("navapi::NAVGetVirusInfo", _wrap_NAVGetVirusInfo, file);
	 newXS("navapi::NAVGetVirusDefCount", _wrap_NAVGetVirusDefCount, file);
	 newXS("navapi::NAVLoadVirusDef", _wrap_NAVLoadVirusDef, file);
	 newXS("navapi::NAVReleaseVirusDef", _wrap_NAVReleaseVirusDef, file);
	 newXS("navapi::NAVGetVirusDefInfo", _wrap_NAVGetVirusDefInfo, file);
	 newXS("navapi::NAVLoadVirusDefTable", _wrap_NAVLoadVirusDefTable, file);
	 newXS("navapi::NAVReleaseVirusDefTable", _wrap_NAVReleaseVirusDefTable, file);
	 newXS("navapi::NAVGetVirusDefTableCount", _wrap_NAVGetVirusDefTableCount, file);
	 newXS("navapi::NAVGetVirusDefTableInfo", _wrap_NAVGetVirusDefTableInfo, file);
	 newXS("navapi::NAVGetNavapiVersionString", _wrap_NAVGetNavapiVersionString, file);
	 newXS("navapi::NAVGetVirusDBInfo", _wrap_NAVGetVirusDBInfo, file);
	 newXS("navapi::CallBackInit", _wrap_CallBackInit, file);
	 newXS("navapi::VIRUSDBINFO_dwVersion_set", _wrap_VIRUSDBINFO_dwVersion_set, file);
	 newXS("navapi::VIRUSDBINFO_dwVersion_get", _wrap_VIRUSDBINFO_dwVersion_get, file);
	 newXS("navapi::VIRUSDBINFO_wDay_set", _wrap_VIRUSDBINFO_wDay_set, file);
	 newXS("navapi::VIRUSDBINFO_wDay_get", _wrap_VIRUSDBINFO_wDay_get, file);
	 newXS("navapi::VIRUSDBINFO_wMonth_set", _wrap_VIRUSDBINFO_wMonth_set, file);
	 newXS("navapi::VIRUSDBINFO_wMonth_get", _wrap_VIRUSDBINFO_wMonth_get, file);
	 newXS("navapi::VIRUSDBINFO_wYear_set", _wrap_VIRUSDBINFO_wYear_set, file);
	 newXS("navapi::VIRUSDBINFO_wYear_get", _wrap_VIRUSDBINFO_wYear_get, file);
/*
 * These are the pointer type-equivalency mappings. 
 * (Used by the SWIG pointer type-checker).
 */
	 SWIG_RegisterMapping("UINT","BOOL",0);
	 SWIG_RegisterMapping("UINT","unsigned int",0);
	 SWIG_RegisterMapping("UINT","int",0);
	 SWIG_RegisterMapping("struct tagVIRUSDBINFOPtr","LPVIRUSDBINFO",0);
	 SWIG_RegisterMapping("DWORDPtr","LPDWORD",0);
	 SWIG_RegisterMapping("unsigned shortPtr","LPWORD",0);
	 SWIG_RegisterMapping("unsigned short","short",0);
	 SWIG_RegisterMapping("LPDWORD","DWORDPtr",0);
	 SWIG_RegisterMapping("struct tagNAVFILEIO","NAVFILEIO",0);
	 SWIG_RegisterMapping("struct tag_HVIRUSDEFTABLEPtr","HNAVVIRUSDEFTABLE",0);
	 SWIG_RegisterMapping("HNAVVIRUSDEF","struct tag_HVIRUSDEFPtr",0);
	 SWIG_RegisterMapping("LPWORD","unsigned shortPtr",0);
	 SWIG_RegisterMapping("VIRUSDBINFO","struct tagVIRUSDBINFO",0);
	 SWIG_RegisterMapping("VIRUSDBINFO","tagVIRUSDBINFO",0);
	 SWIG_RegisterMapping("struct tag_HVIRUSDEFPtr","HNAVVIRUSDEF",0);
	 SWIG_RegisterMapping("enum enumNAVVirusInfo","NAVVIRINFO",0);
	 SWIG_RegisterMapping("LPLPSTR","LPSTRPtr",0);
	 SWIG_RegisterMapping("tagVIRUSDBINFO","VIRUSDBINFO",0);
	 SWIG_RegisterMapping("tagVIRUSDBINFO","struct tagVIRUSDBINFO",0);
	 SWIG_RegisterMapping("long","NAVSTATUS",0);
	 SWIG_RegisterMapping("long","LONG",0);
	 SWIG_RegisterMapping("long","DWORD",0);
	 SWIG_RegisterMapping("long","unsigned long",0);
	 SWIG_RegisterMapping("long","signed long",0);
	 SWIG_RegisterMapping("LPBOOL","BOOLPtr",0);
	 SWIG_RegisterMapping("signed short","short",0);
	 SWIG_RegisterMapping("longPtr","LPLONG",0);
	 SWIG_RegisterMapping("LPBYTE","BYTEPtr",0);
	 SWIG_RegisterMapping("LPLONG","longPtr",0);
	 SWIG_RegisterMapping("struct tagNAVFILEIOPtr","LPNAVFILEIO",0);
	 SWIG_RegisterMapping("struct tagVIRUSDBINFO","VIRUSDBINFO",0);
	 SWIG_RegisterMapping("struct tagVIRUSDBINFO","tagVIRUSDBINFO",0);
	 SWIG_RegisterMapping("LPINT","intPtr",0);
	 SWIG_RegisterMapping("signed int","BOOL",0);
	 SWIG_RegisterMapping("signed int","int",0);
	 SWIG_RegisterMapping("HNAVENGINE","struct tag_VCONTEXTTYPEPtr",0);
	 SWIG_RegisterMapping("charPtr","LPTSTR",0);
	 SWIG_RegisterMapping("charPtr","LPSTR",0);
	 SWIG_RegisterMapping("DWORD","NAVSTATUS",0);
	 SWIG_RegisterMapping("DWORD","LONG",0);
	 SWIG_RegisterMapping("DWORD","unsigned long",0);
	 SWIG_RegisterMapping("DWORD","long",0);
	 SWIG_RegisterMapping("intPtr","LPINT",0);
	 SWIG_RegisterMapping("BYTEPtr","LPBYTE",0);
	 SWIG_RegisterMapping("NAVVIRINFO","enum enumNAVVirusInfo",0);
	 SWIG_RegisterMapping("LPVIRUSDBINFO","struct tagVIRUSDBINFOPtr",0);
	 SWIG_RegisterMapping("struct tag_HVIRUSPtr","HNAVVIRUS",0);
	 SWIG_RegisterMapping("BOOL","int",0);
	 SWIG_RegisterMapping("BOOL","signed int",0);
	 SWIG_RegisterMapping("BOOL","unsigned int",0);
	 SWIG_RegisterMapping("BOOL","UINT",0);
	 SWIG_RegisterMapping("short","unsigned short",0);
	 SWIG_RegisterMapping("short","signed short",0);
	 SWIG_RegisterMapping("NAVSTATUS","DWORD",0);
	 SWIG_RegisterMapping("NAVSTATUS","long",0);
	 SWIG_RegisterMapping("NAVSTATUS","unsigned long",0);
	 SWIG_RegisterMapping("NAVSTATUS","LONG",0);
	 SWIG_RegisterMapping("unsigned long","NAVSTATUS",0);
	 SWIG_RegisterMapping("unsigned long","LONG",0);
	 SWIG_RegisterMapping("unsigned long","DWORD",0);
	 SWIG_RegisterMapping("unsigned long","long",0);
	 SWIG_RegisterMapping("NAVFILEIO","struct tagNAVFILEIO",0);
	 SWIG_RegisterMapping("int","BOOL",0);
	 SWIG_RegisterMapping("int","UINT",0);
	 SWIG_RegisterMapping("int","unsigned int",0);
	 SWIG_RegisterMapping("int","signed int",0);
	 SWIG_RegisterMapping("BOOLPtr","LPBOOL",0);
	 SWIG_RegisterMapping("HNAVVIRUSDEFTABLE","struct tag_HVIRUSDEFTABLEPtr",0);
	 SWIG_RegisterMapping("LPSTRPtr","LPLPSTR",0);
	 SWIG_RegisterMapping("unsigned int","BOOL",0);
	 SWIG_RegisterMapping("unsigned int","UINT",0);
	 SWIG_RegisterMapping("unsigned int","int",0);
	 SWIG_RegisterMapping("LPNAVFILEIO","struct tagNAVFILEIOPtr",0);
	 SWIG_RegisterMapping("LPSTR","LPTSTR",0);
	 SWIG_RegisterMapping("LPSTR","charPtr",0);
	 SWIG_RegisterMapping("LONG","NAVSTATUS",0);
	 SWIG_RegisterMapping("LONG","long",0);
	 SWIG_RegisterMapping("LONG","signed long",0);
	 SWIG_RegisterMapping("LONG","unsigned long",0);
	 SWIG_RegisterMapping("LONG","DWORD",0);
	 SWIG_RegisterMapping("LPTSTR","charPtr",0);
	 SWIG_RegisterMapping("LPTSTR","LPSTR",0);
	 SWIG_RegisterMapping("HNAVVIRUS","struct tag_HVIRUSPtr",0);
	 SWIG_RegisterMapping("struct tag_VCONTEXTTYPEPtr","HNAVENGINE",0);
	 SWIG_RegisterMapping("signed long","LONG",0);
	 SWIG_RegisterMapping("signed long","long",0);
	 ST(0) = &sv_yes;
	 XSRETURN(1);
}
