/////////////////////////////////////////////////////////////////////
// Service.h
//
// Copyright 1992-1996 Symantec, Peter Norton Product Group
/////////////////////////////////////////////////////////////////////
//
// $Header:   S:/INCLUDE/VCS/service.h_v   1.1   24 Apr 1997 19:58:56   JBRENNA  $
//
// Description:
//    This header file declares a class that will take care of service
//    registration and initialization.  To use this class, derive a
//    service object from it and customize it for your specific purpose.
//
//
/////////////////////////////////////////////////////////////////////
// $Log:   S:/INCLUDE/VCS/service.h_v  $
// 
//    Rev 1.1   24 Apr 1997 19:58:56   JBRENNA
// Tesla port: revs 1.24 (DSACKIN) to 1.1 (TSmith).
// 
//    Rev 1.0   13 Mar 1997 15:10:32   RFULLER
// Initial revision
// 
//    Rev 1.1   21 Jan 1997 13:25:30   TSmith
// Added another suplimental string to 'LogEvent' and 'ErrorHandler'
// 
//    Rev 1.0   08 Nov 1996 11:35:10   DKEEFER
// Initial revision
// 
//    Rev 1.29   06 Nov 1996 09:04:26   TSmith
// Modified 'LogEvent' and 'ErrorHandler' functions to accept up to 5 strings.
//
//    Rev 1.28   30 Oct 1996 13:51:12   TSmith
// Another RC.EXE complaint fixed.
//
//    Rev 1.27   30 Oct 1996 13:41:32   TSmith
// Fixed lack of CR\LF at EOF that caused RC.EXE to error out.
//
//    Rev 1.26   25 Oct 1996 09:57:08   TSmith
// Removed obsolete #ifdef DEBUG_PROFILE block delimiters.
//
//    Rev 1.25   24 Oct 1996 01:06:40   DSACKIN
// Added full UNICODE/NON-UNICODE support.
//
//    Rev 1.24   06 Sep 1996 17:28:30   DSACKIN
// Changed the MAX_MESSAGE length so that we could support a bigger message.
//
//    Rev 1.23   05 Aug 1996 19:03:52   DSACKIN
// Added default values for ErrorHandler function.
//
//    Rev 1.22   05 Aug 1996 18:01:30   DSACKIN
// Removed m_pSid from the member variable list.  We really need to be passing
// this in to the ErrorHandler and LogEvent functions to be thread safe.
//
//    Rev 1.21   05 Aug 1996 15:42:10   DSACKIN
// Re-Worked LogEvent and ErrorHandler to take a fixed number of strings.
// Additional strings will be taken care of by C++ default values.
//
//    Rev 1.20   02 Aug 1996 08:42:46   PVENKAT
// Added PSID as a member variable to be used on NTLogEvent.
//
//
//    Rev 1.19   01 Aug 1996 08:54:28   PVENKAT
// Modified max # of string that can be passed to LogEvent to 10 (from 3).
// To add Action String also.
//
//    Rev 1.18   25 Jul 1996 18:48:12   DSACKIN
//
//
//    Rev 1.17   28 Jun 1996 14:11:58   DSACKIN
// ERR_ALL shouldn't automatically be fatal.  It should just Log to NT
// Event long and also display a message box.
//
//    Rev 1.16   27 Jun 1996 17:07:22   DSACKIN
// Added m_bExitingService variable.
//
//    Rev 1.15   20 Jun 1996 02:26:20   DSACKIN
// Include PROFILER.H at the very top.  DEBUG_PROFILE is no longer going
// to be set in the makefile.  It will now come from PROFILER.H.
//
//    Rev 1.14   13 Jun 1996 17:15:20   DSACKIN
// Added declarations for Profiling functions.
//
//    Rev 1.13   05 Jun 1996 22:19:14   DSACKIN
// Added the AllowPauseContinue function.
//
//    Rev 1.12   19 Apr 1996 18:53:02   DSACKIN
// Added LogEventID.
//
//    Rev 1.11   16 Apr 1996 16:16:56   DSACKIN
// Changed the MC constant to fit into a WORD.
//
//    Rev 1.10   16 Apr 1996 14:07:34   DSACKIN
// Added defines for ERROR HANDLER flags.
//
//    Rev 1.9   16 Apr 1996 12:02:56   DSACKIN
// Made ReportStatusToSCMgr public.
//
//    Rev 1.8   12 Apr 1996 17:20:30   DSACKING
// Added a new ErrorHandlerID routine.
//
//    Rev 1.7   11 Apr 1996 16:43:10   DSACKING
// Changed a couple of the return values so that we can take resources out of
// the class and make it a lib file.  Modified DECLARE_SERVICE.
//
//    Rev 1.6   11 Apr 1996 15:47:02   DSACKING
// Removed the SYM_EXPORT and WINAPI to make it a LIB again.
//
//    Rev 1.5   11 Apr 1996 14:29:24   DSACKING
// Removed include "srvcres.h"
//
//    Rev 1.4   11 Apr 1996 13:32:26   DSACKING
// Fixed a variable declaration.
//
//    Rev 1.3   11 Apr 1996 13:26:50   DSACKING
// Made ghInst a member variable (m_hInst) that gets set at construction.
//
//    Rev 1.2   10 Apr 1996 18:35:44   PVENKAT
// Added resources/messages and modified ErrorHandler for NT Log.
// This header includes a ghost header which will be generated by MC. (SRVCMSG.h)
//
//
//    Rev 1.1   10 Apr 1996 16:30:02   DSACKING
// Added SYM_EXPORT WINAPI to public member function.
//
//    Rev 1.0   09 Apr 1996 11:23:10   DSACKING
// Initial revision.
//
/////////////////////////////////////////////////////////////////////

#if !defined(__SERVICE_H)
#define __SERVICE_H

#if !defined(__PROFILER_H)
#include "profiler.h"
#endif // if !defined(__PROFILER_H)


/////////////////////////////////////////////////////////////////////
// Here we need to make some distinctions for a couple of the
// different functions that will be either using UNICODE or not using
// UNICODE.  The problem comes when trying to set default values.  If
// all of the strings come in with default values, the two functions
// would be ambiguous to the compiler.  To get around this, we must
// put in a W version of the function for UNICODE and an A version
// of the function for non-UNICODE (following the Microsoft standard)

#if defined( UNICODE )
#   define LogEvent      LogEventW
#   define ErrorHandler  ErrorHandlerW
#else
#   define LogEvent      LogEventA
#   define ErrorHandler  ErrorHandlerA
#endif



/////////////////////////////////////////////////////////////////////
// Global Defines

#define         PLAT_WIN31                              (0x0000)
#define         PLAT_WIN95                              (0x0001)
#define         PLAT_WINNT                              (0x0002)

#define MAX_SERVICE_NAME_LENGTH (256)
#define MAX_MESSAGE_LEN         (512)   // Max leng for EventLog msg
#define MAX_STRINGS             (6)     // Max # of variable # args for Log

/////////////////////////////////////////////////////////////////////
// Define flags for how to treat an ErrorHandler Call.
//
// The base message ID will only be the low word of the error ID.
// the high word can be used to set flags as to how the message should
// be displayed or reported.

#define	ID_ERR_LOGEVENT   (0x10000) // Event will be added to event log
#define	ID_ERR_MESSAGEBOX (0x20000) // Will display a message box notification
#define	ID_ERR_FATAL      (0x40000) // Will abort our service

                                     // ERR_ALL combines all of the types.
#define  ID_ERR_ALL        (ID_ERR_LOGEVENT | \
                            ID_ERR_MESSAGEBOX)

/////////////////////////////////////////////////////////////////////
// This define is used for getting the event log message ID.
//
// Bitwise OR this value with the WORD string ID to get the MC resource
// message ID.

#define ID_ERR_MCBASE      (0x8000)    // String ID | ID_ERR_MCBASE = MC ID.

/////////////////////////////////////////////////////////////////////
// Here is where we define the MC resource message categories

#define ID_ERR_CAT_SUCCESS      (0)     // Success category
#define ID_ERR_CAT_INFORMATION  (1)     // Informational category
#define ID_ERR_CAT_WARNING      (2)     // Warning category
#define ID_ERR_CAT_ERROR        (3)     // Error category

/////////////////////////////////////////////////////////////////////
// CService specific Error Codes

#define ERROR_STARTSERVICECTRLDISPATCHER    (1)


#if !defined(__TIMERCLI_H)
#	include "timercli.h"
#endif // if !defined(__TIMERCLI_H)

/////////////////////////////////////////////////////////////////////
// CService : Declaration

class CService
{
public:
   HINSTANCE m_hInst;                   // Handle to our instance.

private:

   SERVICE_STATUS_HANDLE m_hStatus;     // Service Handle
   SERVICE_STATUS        m_sStatus;     // Status Structure

   WCHAR m_szServiceName[MAX_SERVICE_NAME_LENGTH + 1];
   WCHAR m_szModuleFileName[SYM_MAX_PATH + 1];

   BOOL   m_bExe;                       // Are we running as an EXE?
   WORD   m_wPlatform;                  // Win95 or WinNT.
   HANDLE m_hEvent;                     // Event handle
   DWORD  m_dwErrorCode;                // Our last error code
   DWORD  m_dwStep;                     // What step of execution are we at?
   BOOL   m_bPauseContinue;             // Allow Pause/Continue?
   BOOL   m_bAllowStop;                 // Allow Stop?

   BOOL   m_bExitingService;            // Set this to prevent recursion.

   LPSERVICE_MAIN_FUNCTIONW m_pMain;    // Our Main Function Callback
   LPHANDLER_FUNCTION       m_pHandler; // Our Handler function

   CTimerClient m_cTimer;


public:
   CService(
      LPSERVICE_MAIN_FUNCTIONW pMain,      // Pointer to our Main callback
      LPHANDLER_FUNCTION       pHandler);  // Pointer to our Handler callback
   ~CService();                            // Takes care of our cleanup.

   DWORD Create(LPWSTR szServiceName);  // Starts the service running - UNICODE version
   DWORD Create(LPSTR szServiceName);   // Starts the service running - non-UNICODE version

                                        // Override the following functions
                                        // for specific Service Starting
                                        // tasks.
   virtual BOOL ServiceMain (DWORD dwArgc, LPWSTR *lpszArgv);
   virtual VOID InitService (VOID);
   VOID Handler(DWORD dwCtrlCode);      // Processes request from Service Mgr
                                        // Calls ServiceControlxxx functions

                                        // The following functions are used
                                        // for receiving specific requests
                                        // from the Service Manager
   virtual VOID ServiceControlPause(VOID);
   virtual VOID ServiceControlContinue(VOID);
   virtual VOID ServiceControlStop(VOID);
   virtual VOID ServiceControlUser(DWORD dwCtrlCode);


                                        // This version will become LogEventA
                                        // or LogEventW depending on the
                                        // UNICODE define above.
   BOOL LogEvent(
      DWORD  dwErrID,                   // [in] - ID of event to log
      LPTSTR lpszString1 = NULL,        // [in] [optional] supplimentary string
      LPTSTR lpszString2 = NULL,        // [in] [optional] supplimentary string
      LPTSTR lpszString3 = NULL,        // [in] [optional] supplimentary string
      LPTSTR lpszString4 = NULL,        // [in] [optional] supplimentary string
      LPTSTR lpszString5 = NULL,        // [in] [optional] supplimentary string
      LPTSTR lpszString6 = NULL,        // [in] [optional] supplimentary string
      PSID   pSid = NULL);              // [in] [optional] SID to use in logging

#ifdef UNICODE

   BOOL LogEventA(
      DWORD  dwErrID,                   // [in] - ID of event to log
      LPSTR lpszString1 = NULL,         // [in] [optional] supplimentary string
      LPSTR lpszString2 = NULL,         // [in] [optional] supplimentary string
      LPSTR lpszString3 = NULL,         // [in] [optional] supplimentary string
      LPSTR lpszString4 = NULL,         // [in] [optional] supplimentary string
      LPSTR lpszString5 = NULL,         // [in] [optional] supplimentary string
      LPSTR lpszString6 = NULL,         // [in] [optional] supplimentary string
      PSID   pSid = NULL);              // [in] [optional] SID to use in logging

#else // ifdef UNICODE

   BOOL LogEventW(
      DWORD  dwErrID,                   // [in] - ID of event to log
      LPWSTR lpszString1 = NULL,        // [in] [optional] supplimentary string
      LPWSTR lpszString2 = NULL,        // [in] [optional] supplimentary string
      LPWSTR lpszString3 = NULL,        // [in] [optional] supplimentary string
      LPWSTR lpszString4 = NULL,        // [in] [optional] supplimentary string
      LPWSTR lpszString5 = NULL,        // [in] [optional] supplimentary string
      LPTSTR lpszString6 = NULL,        // [in] [optional] supplimentary string
      PSID   pSid = NULL);              // [in] [optional] SID to use in logging

#endif // ifdef UNICODE


                                        // This version will become ErrorHandlerA
                                        // or ErrorHandlerW depending on the
                                        // UNICODE define above.
   VOID ErrorHandler (
      DWORD  dwErrID,                   // [in] - ID of event to log
      LPTSTR lpszString1 = NULL,        // [in] [optional] supplimentary string
      LPTSTR lpszString2 = NULL,        // [in] [optional] supplimentary string
      LPTSTR lpszString3 = NULL,        // [in] [optional] supplimentary string
      LPTSTR lpszString4 = NULL,        // [in] [optional] supplimentary string
      LPTSTR lpszString5 = NULL,        // [in] [optional] supplimentary string
      LPTSTR lpszString6 = NULL,        // [in] [optional] supplimentary string
      PSID   pSid = NULL);              // [in] [optional] SID to use in logging

#ifdef UNICODE

   VOID ErrorHandlerA (
      DWORD  dwErrID,                   // [in] - ID of event to log
      LPSTR lpszString1 = NULL,         // [in] [optional] supplimentary string
      LPSTR lpszString2 = NULL,         // [in] [optional] supplimentary string
      LPSTR lpszString3 = NULL,         // [in] [optional] supplimentary string
      LPSTR lpszString4 = NULL,         // [in] [optional] supplimentary string
      LPSTR lpszString5 = NULL,         // [in] [optional] supplimentary string
      LPSTR lpszString6 = NULL,         // [in] [optional] supplimentary string
      PSID   pSid = NULL);              // [in] [optional] SID to use in logging

#else // ifdef UNICODE

   VOID ErrorHandlerW (
      DWORD  dwErrID,                   // [in] - ID of event to log
      LPWSTR lpszString1 = NULL,        // [in] [optional] supplimentary string
      LPWSTR lpszString2 = NULL,        // [in] [optional] supplimentary string
      LPWSTR lpszString3 = NULL,        // [in] [optional] supplimentary string
      LPWSTR lpszString4 = NULL,        // [in] [optional] supplimentary string
      LPWSTR lpszString5 = NULL,        // [in] [optional] supplimentary string
      LPWSTR lpszString6 = NULL,        // [in] [optional] supplimentary string
      PSID   pSid = NULL);              // [in] [optional] SID to use in logging

#endif // ifdef UNICODE

                                        // Use this function to report to
                                        // the Service Manager
   BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                            DWORD dwWin32ExitCode,
                            DWORD dwWaitHint);

                                        // TRUE- allow pause, FALSE do not.
   VOID AllowPauseContinue(
      BOOL bPauseContinue);

                                        // TRUE- allow Stop, FALSE do not.
   VOID AllowStop(
      BOOL bAllowStop);

                                        // These are the profiling functions
   VOID InitializeProfiler(
      LPTSTR lpszServiceName);          // [in] - The name of the service
#ifdef UNICODE
   VOID InitializeProfiler(
      LPSTR lpszServiceName);           // [in] - The name of the service
#else // UNICODE
   VOID InitializeProfiler(
      LPWSTR lpszServiceName);          // [in] - The name of the service
#endif // UNICODE

   VOID LogMessage(
      LPTSTR lpszMessage);              // [in] - Message to send
#ifdef UNICODE
   VOID LogMessage(
      LPSTR lpszMessage);               // [in] - Message to send
#else // UNICODE
   VOID LogMessage(
      LPWSTR lpszMessage);              // [in] - Message to send
#endif // UNICODE

   VOID LogMessage(
      LPTSTR lpszMessage,               // [in] - Message to send
      LPTSTR lpszString);               // [in] - Support string for message
#ifdef UNICODE
   VOID LogMessage(
      LPSTR lpszMessage,                // [in] - Message to send
      LPSTR lpszString);                // [in] - Support string for message
#else // UNICODE
   VOID LogMessage(
      LPWSTR lpszMessage,               // [in] - Message to send
      LPWSTR lpszString);               // [in] - Support string for message
#endif // UNICODE

   VOID LogMessage(
      LPTSTR lpszMessage,               // [in] - Message to send
      DWORD  dwValue);                  // [in] - Support value for message
#ifdef UNICODE
   VOID LogMessage(
      LPSTR lpszMessage,                // [in] - Message to send
      DWORD  dwValue);                  // [in] - Support value for message
#else // UNICODE
   VOID LogMessage(
      LPWSTR lpszMessage,               // [in] - Message to send
      DWORD  dwValue);                  // [in] - Support value for message
#endif // UNICODE

};

   // This macro is ugly, but for each CService you want, you need to be
   // able to have callbacks that are C functions that do not take a "this"
   // as a first function.  When declaring your CService, the two functions
   //

#define DECLARE_SERVICE(ObjName,Name,ErrID) \
\
void WINAPI Name##Main(DWORD dwArgc, LPWSTR *lpszArgv); /* Prototype functions */\
void WINAPI Name##Handler(DWORD dwCtrlCode);\
\
ObjName Name(Name##Main, Name##Handler);\
\
void WINAPI Name##Main(DWORD dwArgc, LPWSTR *lpszArgv)\
{\
   if (!Name.ServiceMain(dwArgc, lpszArgv))\
      Name.ErrorHandler(ErrID);\
}\
\
void WINAPI Name##Handler(DWORD dwCtrlCode)\
{\
   Name.Handler(dwCtrlCode);\
}
#endif // __SERVICE_H
