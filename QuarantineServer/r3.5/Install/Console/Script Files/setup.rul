////////////////////////////////////////////////////////////////////////////////
//
//  IIIIIII SSSSSS
//    II    SS                          InstallShield (R)
//    II    SSSSSS      (c) 1996-1998, InstallShield Software Corporation
//    II        SS      (c) 1990-1996, InstallShield Corporation
//  IIIIIII SSSSSS                     All Rights Reserved.
//
//
//  This code is generated as a starting setup template.  You should
//  modify it to provide all necessary steps for your setup.
//
//
//    File Name:  Setup.rul
//
//  Description:  InstallShield script
//
//     Comments:  This template script performs a basic setup. With minor
//                modifications, this template can be adapted to create
//                new, customized setups.
//
////////////////////////////////////////////////////////////////////////////////


// Include header files

    #include "sdlang.h"
    #include "ifx.h"

////////////////////// string defines ////////////////////////////

    // Custom DLL
    #define CUSTOM_DLLNAME           "NAVINSTNT.DLL"
    #define INSTALL_OPTIONS_FILE     "INSTOPTS.INI"

    // Hawking tracking for aborting installs
    #define HAWKING_NO_ACTIVITY             0
    #define HAWKING_TEMP_DIR_ONLY           1
    #define HAWKING_USING_DEFS              2

    // Registry keys
    #define MICROSOFT_MANAGEMENT_CONSOLE    "SOFTWARE\\Microsoft\\MMC"
    #define SYMANTEC_KEY					"\\Software\\Symantec"
    #define SYMANTEC_INSTALLED_APPS_KEY     "\\Software\\Symantec\\InstalledApps"
    #define INTEL_LANDESK_KEY      		    "\\Software\\Intel\\LanDesk"
    #define SYMANTEC_QUARNATINE_KEY         "\\Software\\Symantec\\Quarantine"
    #define SYMANTEC_QCONSOLE_KEY           "\\Software\\Symantec\\Quarantine\\Console"
    #define MSIE_REG_KEY                    "SOFTWARE\\Microsoft\\Internet Explorer"   
    #define MS_TERMSERVICE_KEY              "SYSTEM\\CurrentControlSet\\Services\\TermService"
    #define NSCEM_CONSOLE                   "SSCADMIN"

    // AMS Install Flags
    #define AMS_FLAGS_SERVER            0x0001
    #define AMS_FLAGS_CONSOLE           0x0002
    #define AMS_FLAGS_CLIENT            0x0004
    #define AMS_FLAGS_CLIENTLITE        0x0008

    #define MAX_AMSINSTALL_STRLEN       512

    #define AMS_PRODUCT_NAME            "LDVP"
    #define AMS_INSTALL_DLL             "InstallAMS.DLL"
    #define AMS_INSTALLBIN_PATH         "AMS2\\WINNT"
    #define AMSCONSOLEINSTALLED_VALUE   "AMSConsoleInstalled"
    #define AMSINSTALLPATH_VALUE        "AMSInstallPath"

    #define MSIE_REQ_VERSION            "5.50.4807.2300"
    #define SERVICE_PACK_REQ            "Service Pack 6"
    #define  RUNONCE_KEY        		"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce"

//////////////////// installation declarations ///////////////////

// ----- DLL function prototypes -----

     // functions exported from "NAVInst" custom DLL
     //JA Do not make 2nd param below value "BYVAL STRING"
    prototype   cdecl BOOL    NAVINSTNT.GetDefsDirectory(BYVAL STRING, BYREF STRING);
    prototype   cdecl BOOL    NAVINSTNT.CopyVirusDefinitionFiles(BYVAL STRING);
    prototype   cdecl NUMBER  NAVINSTNT.GetNT40ServicePack();

    // functions export from "InstallAMS" custom DLL
    prototype cdecl InstallAMS.InstallAMS2( BYVAL STRING, BYVAL STRING, BYVAL STRING, NUMBER, NUMBER,BOOL );

    // functions exported from "Kernel32" DLL
    prototype   NUMBER  Kernel32.GetCurrentDirectory(NUMBER,POINTER);
    prototype   BOOL    Kernel32.SetCurrentDirectory(BYVAL STRING);

    // functions exported from "User32" DLL
    prototype   INT     User32.GetKeyboardType(INT);

    // functions exported from "qcinst" DLL
    prototype cdecl qcinst.UninstInitialize(HWND);
    prototype cdecl qcinst.UninstUnInitialize(HWND);
    prototype cdecl qcinst.IsNT4TerminalServer();
    prototype cdecl qcinst.IsFolderWriteable( BYVAL STRING );
    prototype cdecl qcinst.CleanupScandlvr();

// ---- script function prototypes -----

    // generated by the Project Wizard
    export prototype ProcessAfterDataMove(HWND);
    export prototype ProcessAfterDataMove_RB(HWND);
    export prototype SetupRegistry(HWND);
    export prototype SetupRegistry_RB(HWND);
    export prototype UnSetupRegistry(HWND);
    export prototype UnSetupRegistry_RB(HWND);
    export prototype SetupInstall(HWND);
    export prototype CheckRequirements(HWND);
    export prototype AMSSetup_RB(HWND);
    export prototype AMSSetup(HWND);
    export prototype UnAMSSetup_RB(HWND);
    export prototype UnAMSSetup(HWND);
    export prototype IsNEC(HWND);
    export prototype RegisterQServerPS(HWND);

    // Hawking specific prototypes
    export prototype HandleVirusDefs(HWND);
    prototype UpdateVirusDefs();
    prototype UpdateFilesFromArchive(STRING, STRING, STRING);
    prototype IsAcceptableNTServicePack(); // CMM -- 07/28/99
    prototype IsMMCInstalled();
    prototype QConsoleInstalled();
    prototype IsIE5Installed();   
    export prototype CheckInstallDir(HWND);
    export prototype CheckBrowseDir(HWND);
    export prototype Uninstall(HWND);
    export prototype CopyVirusDefs(HWND);
    export prototype HideUninstallCancelButton(HWND);

    prototype CheckDir(HWND, STRING);
    prototype DeleteIfRegKeyIsEmpty(STRING);

    export prototype ResetScandlvr(HWND);

    // ----- global variables ------

    // generated by the Project Wizard
    BOOL        bIsWindowsNT4, bIsWindowsNT351, bIsWindows98, bIsWindows95;
    BOOL        bIsShellExplorer, bInstallAborted, bIs32BitSetup;
    STRING      svDir;
    STRING      svName, svCompany, svSerial;
    STRING      svDefGroup;
    STRING      szAppPath;
    STRING      svSetupType;
    LIST        listStartCopy;

    // your global variables
    STRING      g_szAppPath;
    STRING      szTitle;
    STRING      szMsg;
    STRING      szDLL;
    STRING      szDefUtilsDir;
    STRING      szInstallOptsFile;
    NUMBER      nvMMCInstalled;
    NUMBER      nvHawkingStatus;

///////////////////////////////////////////////////////////////////////////////
//
// Function: ProcessAfterDataMove
//
//  Purpose: This function performs any necessary operations needed after
//           all files have been transferred.
//
///////////////////////////////////////////////////////////////////////////////
function ProcessAfterDataMove(hMSI)
begin
    // Delete the superfluous key created by the call to InstallationInfo()
    RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
    RegDBDeleteKey("SOFTWARE\\Symantec\\Symantec AntiVirus Quarantine Console");

    // Update virus defs from external archive.
    UpdateVirusDefs();

    return 0;
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: ProcessAfterDataMove_RB
//
//  Purpose: This function rollsback any actions taken by
//	ProcessAfterDataMove.
//
///////////////////////////////////////////////////////////////////////////////
function ProcessAfterDataMove_RB(hMSI)
    STRING szExecutable;
    STRING szAMSInstallStatus[MAX_AMSINSTALL_STRLEN + 1];
    STRING szAMSFolder;
    NUMBER nResult;
    NUMBER nAMSStatusLen;
begin

	// *WORK*

    // Update virus defs from external archive.
//    UpdateVirusDefs();

    return 0;
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: ResetScandlvr
//
//  Purpose: This function uses QCInst.dll to check for SAV Server being installed
//	SAV Server requires re-registering ScanDlvr.dll on remove
//
///////////////////////////////////////////////////////////////////////////////
function ResetScandlvr(hMSI)
     NUMBER nvType;
     NUMBER nvSize;
     STRING szQConsolePath;
     NUMBER nvResult,nResult;
begin
	// cleanup ScanDlvr registration (could still be needed by SAV server)
	// need to load QCInst.dll to do this
	// Set HKLM
	RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);	
	// Get SSC Install directory from registry
	nvResult = RegDBGetKeyValueEx(SYMANTEC_INSTALLED_APPS_KEY,
								  "QConsole",
								  nvType,
								  szQConsolePath,
								  nvSize);       
	// Get path to custom dll	
	nResult=UseDLL( szQConsolePath^"qcinst.dll" );
	if(nResult < 0)then
   		MessageBox( "qcinst.dll(2) FAILED - ", INFORMATION );
		endif;

	// call to re-register scandlvr (if necessary)
	CleanupScandlvr();

	UnUseDLL( szQConsolePath ^ "qcinst.dll" ) ;  
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: UnSetupRegistry
//
//  Purpose: This function deletes the registry entries for this setup.
//
///////////////////////////////////////////////////////////////////////////////
function UnSetupRegistry(hMSI)
     NUMBER nvType;
     NUMBER nvSize;
     NUMBER nUsgCnt;
     STRING szKey;
     STRING szValue;
     STRING szValueName;
     STRING svValueData;

begin
    RegDBSetDefaultRoot (HKEY_LOCAL_MACHINE);

    szKey = SYMANTEC_INSTALLED_APPS_KEY;
    RegDBCreateKeyEx(szKey, "");

    // Process the VP6UsageCount Key.
    szValueName = "VP6UsageCount";

    if( 0 = RegDBGetKeyValueEx( szKey, szValueName, nvType, svValueData, nvSize ) ) then
        StrToNum( nUsgCnt, svValueData );
        // decrement the usage count.
        nUsgCnt = nUsgCnt - 1;
        if( nUsgCnt = 0 ) then
        	RegDBDeleteValue( szKey, szValueName );
        else
	        NumToStr( szValue, nUsgCnt );
	        // set the new value.
	        RegDBSetKeyValueEx( szKey, szValueName, REGDB_NUMBER, szValue, -1 );
        endif;
    // else
        // The key doesn't exist so no worries!
    endif;

    // Conditional delete for various keys - these are keys that we do
    // not own, but if we were the only app on the machine that used
    // them, then we should clean them up.
    DeleteIfRegKeyIsEmpty( SYMANTEC_QCONSOLE_KEY );
	DeleteIfRegKeyIsEmpty( SYMANTEC_QUARNATINE_KEY );
	DeleteIfRegKeyIsEmpty( SYMANTEC_INSTALLED_APPS_KEY );
	DeleteIfRegKeyIsEmpty( SYMANTEC_KEY );
	DeleteIfRegKeyIsEmpty( INTEL_LANDESK_KEY );

    return 0;
 end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: UnSetupRegistry_RB
//
//  Purpose: This function restores the registry entries for this setup.
//
///////////////////////////////////////////////////////////////////////////////
function UnSetupRegistry_RB(hMSI)
begin
	SetupRegistry(hMSI);
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: SetupRegistry
//
//  Purpose: This function makes the registry entries for this setup.
//
///////////////////////////////////////////////////////////////////////////////
function SetupRegistry(hMSI)
     NUMBER nvType;
     NUMBER nvSize;
     NUMBER nUsgCnt;
     STRING szKey;
     STRING szValue;
     STRING szValueName;
     STRING svValueData;

begin
    szKey = SYMANTEC_INSTALLED_APPS_KEY;
    RegDBCreateKeyEx(szKey, "");

    // Process the VP6UsageCount Key.
    szValueName = "VP6UsageCount";

    if( 0 = RegDBGetKeyValueEx( szKey, szValueName, nvType, svValueData, nvSize ) ) then
        StrToNum( nUsgCnt, svValueData );
        // increment the usage count.
        nUsgCnt = nUsgCnt + 1;
        NumToStr( szValue, nUsgCnt );
        // set the new value.
        RegDBSetKeyValueEx( szKey, szValueName, REGDB_NUMBER, szValue, -1 );
    else
        // The key doesn't exist so create it and give it a usage count of 1.
        RegDBSetKeyValueEx( szKey, szValueName, REGDB_NUMBER, "1", -1 );
    endif;

    return 0;
 end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: SetupRegistry_RB
//
//  Purpose: This function rolls back the registry entries for this setup.
//
///////////////////////////////////////////////////////////////////////////////
function SetupRegistry_RB(hMSI)
begin
	UnSetupRegistry(hMSI);
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: SetupInstall
//
//  Purpose: This will initialize the setup.  Any general initialization
//           needed for the installation should be performed here.
//
///////////////////////////////////////////////////////////////////////////////
function SetupInstall(hMSI)

    NUMBER nResult;
    STRING svTempString;
begin


    bInstallAborted = FALSE;
    FindAllFiles (TempFolder, "\\"+INSTALL_OPTIONS_FILE, svTempString, RESET);
    szInstallOptsFile = svTempString ^ INSTALL_OPTIONS_FILE;

    // load the custom DLL
    FindAllFiles (TempFolder, "\\"+CUSTOM_DLLNAME, szDLL, RESET);
    if (0 != UseDLL(szDLL)) then
        if (MODE = SILENTMODE) then
            abort;
        else
            MessageBox(@ID_ERROR_LOADING_CUSTOM_DLL, SEVERE);
            abort;
        endif;
    endif;

    // if we're running in silent mode and the value fetched from the response
    // file is 'DEFAULT', then use the value we derived in SetupInstall()
    if ((MODE = SILENTMODE)  &&  ("DEFAULT" = svDir)) then
        svDir = g_szAppPath;
        // set the target directory and global app path variable
    	INSTALLDIR = svDir;
    	g_szAppPath = svDir;
    endif;

    return 0;
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function:  CheckRequirements
//
//  Purpose:  This function checks all minimum requirements for the
//            application being installed.  If any fail, then the user
//            is informed and the setup is terminated.
//
///////////////////////////////////////////////////////////////////////////////
function CheckRequirements(hMSI)
    NUMBER  nvDx, nvDy, nvResult;
    STRING  svResult;
    STRING  svIgnored;
    STRING  svTempString;
    STRING  szProductName;
 begin

    bIsShellExplorer = FALSE;
    bIsWindowsNT4    = FALSE;
    bIsWindowsNT351  = FALSE;
    bIsWindows95     = FALSE;
    bIsWindows98     = FALSE;

    szProductName = @ID_PRODUCT_NAME;

    // Check screen resolution.
    GetExtents( nvDx, nvDy );

    if (nvDy < 480) then
        MessageBox( @ID_ERROR_VGARESOLUTION, WARNING );
        abort;
    endif;

    // Set 'setup' operation mode
    bIs32BitSetup = TRUE;
    GetSystemInfo( ISTYPE, nvResult, svResult );
    if (nvResult = 16) then
        bIs32BitSetup = FALSE; // running 16-bit setup
        return 0; // no additional information required
    endif;

    // --- 32-bit testing after this point ---

    // Determine the target system's operating system.
    GetSystemInfo( OS, nvResult, svResult );

    if (nvResult = IS_WINDOWSNT) then
        // Check to see if OS is Windows NT 4.0 or Windows NT 3.51,
        // and if the shell being used is the Explorer shell.
        if (GetSystemInfo( WINMAJOR, nvResult, svResult ) = 0) then
            if ( ((nvResult = 4) && IsAcceptableNTServicePack()) || (nvResult > 4) ) then
                bIsShellExplorer = TRUE;
                bIsWindowsNT4 = TRUE;
            else
                Sprintf(szTitle , @ID_PRODUCTNAME_TITLE_CAPTIONBAR, szProductName);
                szMsg = @ID_ERROR_INVALID_OS;
                // Not running NT4 SP5, alert user and bail out of the install
                SprintfBox(SEVERE, szTitle, szMsg);
                abort;
            endif;
        endif;
    elseif (nvResult = IS_WINDOWS9X) then
        Sprintf(szTitle , @ID_PRODUCTNAME_TITLE_CAPTIONBAR, szProductName);
        szMsg = @ID_ERROR_INVALID_OS;
        // Not running NT4, alert user and bail out of the install
        SprintfBox(SEVERE, szTitle, szMsg);
        abort;
    endif;

    // Check to see if IE 5.0 is installed.
    if ( IsIE5Installed() < 0 ) then
        MessageBox( @ID_ERROR_MSIE_VERSION, INFORMATION );
        abort;
    endif;
                 
 	if( IsMMCInstalled() < 0 )then                  
          MessageBox( @ID_ERROR_MMC_VERSION, INFORMATION );
        abort;
    endif;
    
    // Warn user if QConsole is already installed.
    if(QConsoleInstalled()) then
	Sprintf(szTitle , @ID_PRODUCTNAME_TITLE_CAPTIONBAR, szProductName);
        Sprintf(szMsg, @ID_MSG_ALREADYINSTALLED, szProductName);
        SprintfBox(WARNING,szTitle,szMsg);
        abort;

    endif;
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function:  UpdateVirusDefs
//
//  Purpose:  Retrieves virus specific path information & calls generic
//            function 'UpdateFilesFromArchive' to perform actual file
//            handling.
//
///////////////////////////////////////////////////////////////////////////////
function UpdateVirusDefs()
    NUMBER nType;
    NUMBER nSize;
    NUMBER nResult;
    STRING szIncomingDefDir;

begin
    // Get the virus defs location from registry.
    RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
    nType = REGDB_STRING;
    nResult = RegDBGetKeyValueEx(SYMANTEC_INSTALLED_APPS_KEY, "AVENGEDEFS", nType, szIncomingDefDir, nSize);

    if (nResult < 0) then
        return nResult;
    endif;

    // Put together the 'extract to' path.
    szIncomingDefDir = szIncomingDefDir ^ "INCOMING";
    return UpdateFilesFromArchive(szInstallOptsFile, @ID_ADMIN_DEF_ARCHIVE, szIncomingDefDir);
end;


///////////////////////////////////////////////////////////////////////////////
//
// Function:  UpdateFilesFromArchive
//
//  Purpose:  Queries install options ini file for specified data file archive
//            and copies and extracts it to the specified location.
//
//     Args:  szIniFile - Fully qualifed name of install options file.
//            szSection - Ini section name to query.
//            szTargetDir - Final location for expanded files.
//
///////////////////////////////////////////////////////////////////////////////
function UpdateFilesFromArchive(szIniFile, szSection, szExtractTargetDir)
    STRING szSelfExtPgm;
    STRING szSelfExtDisk;
    STRING szSelfExtArgs;
    STRING szSrcRoot;
    STRING szDisk;
    STRING szMsg;
    STRING szIncomingDefDir;
    STRING szCurDir;
    STRING szOrgCurDir;
    NUMBER nSize;
    NUMBER nResult;
    NUMBER nPos;
    NUMBER nType;
begin
    // Make sure the ini file is where it needs to be.
    if (Is(FILE_EXISTS, szInstallOptsFile) <= 0) then
        return -1;
    endif;

    // Save the items this function may alter.
    VarSave(SRCINSTALLDIR);
    nResult = GetCurrentDirectory(256, &szOrgCurDir);

    // Check the install options file to determine if the files
    // should be updated from an external, self extracting zip file.

    nResult = GetProfString(szIniFile, szSection, @ID_ADMIN_SELF_EXTRACTOR, szSelfExtPgm);

    // If the entry could not be retrieved or is empty, exit.
    if ((nResult < 0) || ("" = szSelfExtPgm)) then
        // No error return value (-1) since this may fail legitimately.
        return 0;
    endif;

    INSTALLDIR = SUPPORTDIR;

    GetProfString(szIniFile, szSection, @ID_ADMIN_ARGUMENTS, szSelfExtArgs);
    GetProfString(szIniFile, szSection, @ID_ADMIN_DISK, szSelfExtDisk);

    // Establish the current working directory
    SetCurrentDirectory(SRCDIR);
    szCurDir = SRCDIR;

    // Try the current source directory for the file.
    if (Is(FILE_EXISTS, szSelfExtPgm)) then
        goto DoFileCopy;
    else
        // Call Win32 to change directory using relative path.
        SetCurrentDirectory("..");
        SetCurrentDirectory(szSelfExtDisk);
        GetCurrentDirectory(256, &szCurDir);
        nResult = Is(FILE_EXISTS, szSelfExtPgm);
        SRCDIR = szCurDir;

        if (TRUE = nResult) then
            goto DoFileCopy;
        else
            Sprintf(szMsg, @ID_DEF_UPDATE_MSG_FMT, szSelfExtPgm);
            nResult = EnterDisk(szMsg, szSelfExtPgm);
            if (OK = nResult) then
                // SRCDIR should be set by EnterDisk
                goto DoFileCopy;
            else
                goto UserCancel;
            endif;
        endif;
    endif;

DoFileCopy:
    nResult = XCopyFile(szSelfExtPgm, "", COMP_NORMAL);
    SetCurrentDirectory(szExtractTargetDir);
    LaunchAppAndWait(SUPPORTDIR ^ szSelfExtPgm, szSelfExtArgs, WAIT);

UserCancel:
    VarRestore(SRCINSTALLDIR);
    nResult = SetCurrentDirectory(szOrgCurDir);
end;

///////////////////////////////////////////////////////////////////////////////
//
//  Function: IsAcceptableNTServicePack
//
//  Purpose: Returns TRUE if they have a service pack installed that we can accept
//           returns FALSE otherwise.
//           Added by Chris McGowen -- 07/28/99
//
///////////////////////////////////////////////////////////////////////////////
// TNILI 5/15/00 Modified to use ISCompareServicePack and check for SP5
///////////////////////////////////////////////////////////////////////////////
function IsAcceptableNTServicePack()
    BOOL bRtnVal;
    NUMBER nvResult;
begin
    bRtnVal = TRUE;

    nvResult = ISCompareServicePack( SERVICE_PACK_REQ );
    // Make sure that SP6 or greater is installed
    if ((nvResult < 0) || (nvResult = LESS_THAN)) then
        bRtnVal = FALSE;
    endif;

    return bRtnVal;
end;

///////////////////////////////////////////////////////////////////////////////
//
//  Function: IsNEC
//
//  Purpose: Returns TRUE if the computer is an NEC computer.
//           Added 7/30/99 -- CMM
//
///////////////////////////////////////////////////////////////////////////////
#if 0
function IsNEC()
    STRING szUser32DLL;
    BOOL bRtnVal;
begin
    bRtnVal = FALSE;
    szUser32DLL = SystemFolder ^ "USER32.DLL";
    if(UseDLL(szUser32DLL) = 0) then
        if ( User32.GetKeyboardType( 0 ) = 7 ) then
            if ( User32.GetKeyboardType( 1 ) > 3328 ) then
                bRtnVal = TRUE;
            endif;
        endif;
        UnUseDLL(szUser32DLL);
    endif;

    return bRtnVal;
end;
#endif

///////////////////////////////////////////////////////////////////////////////
//
//  Function: IsMMCInstalled
//
//  Purpose: Checks to see if MMC is installed.  
//
//	Modified 02/28/03 - Ian Barile
//
///////////////////////////////////////////////////////////////////////////////
function IsMMCInstalled()
    BOOL bInstallMMC;
    STRING svVersionNumber;
begin

    RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
    if( RegDBKeyExist(MICROSOFT_MANAGEMENT_CONSOLE) < 0 ) then
    	return -1;
    endif;   
    
    return 1;
end;

///////////////////////////////////////////////////////////////////////////////
//
//  Function: QConsoleInstalled
//
//  Purpose: Returns TRUE if Quarantine Console is already installed.
//           Added 9/13/99 -- CMM
//
///////////////////////////////////////////////////////////////////////////////
function QConsoleInstalled()
    NUMBER nvType, nvSize;
    STRING svValue;
begin
    RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
    if(RegDBGetKeyValueEx(SYMANTEC_INSTALLED_APPS_KEY, @ID_INSTAPP_VALUE, nvType, svValue,
                          nvSize)=0) then
        return TRUE;
    endif;

    return FALSE;
end;

/////////////////////////////////////////////////////////////////////////////
// Function: IsIE5Installed                                                //
//  Purpose: This function checks for the presence of IE 5.0               //
/////////////////////////////////////////////////////////////////////////////
function IsIE5Installed()
    NUMBER nvType;
    STRING svValue;
    NUMBER nvSize;
    NUMBER nRet;
begin
    // Return 0 for success, -1 for error
    nRet = -1;

    RegDBSetDefaultRoot( HKEY_LOCAL_MACHINE );

    if ( RegDBKeyExist( MSIE_REG_KEY ) < 0 ) then
        goto Error;
    endif;

    if ( RegDBGetKeyValueEx( MSIE_REG_KEY, "Version", nvType, svValue, nvSize ) < 0 ) then
        goto Error;
    endif;

    if ( VerCompare( svValue, MSIE_REQ_VERSION, VERSION ) != LESS_THAN ) then
        nRet = 0;
    endif;

Error:
    RegDBSetDefaultRoot( HKEY_CLASSES_ROOT  );
    return nRet;
end; 


//////////////////////////////////////////////////////////////////////////////
// FUNCTION:	OnUninstall
//
//  EVENT:      Uninstall event is sent when uninstallation is started by the
//              end user from either the Add/Remove programs or by clicking on
//              setup.exe again, after the product has already been installed.
//              This event will only be triggered if the "Enable Maintenance"
//              property in General Information\Project Properties is set to
//              No.  If this property is set to Yes, then the Maintenance
//              events will get triggered.  This event is similar to an IS5
//              uninstallation.   
//
///////////////////////////////////////////////////////////////////////////////
function Uninstall(hMSI)
	STRING szQConsolePath;
	NUMBER nHwnd,nvResult,nResult,nvType,nvSize;
begin 
	
	// Set HKLM
	RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);	
	// Get SSC Install directory from registry
	nvResult = RegDBGetKeyValueEx(SYMANTEC_INSTALLED_APPS_KEY,
								  "QConsole",
								  nvType,
								  szQConsolePath,
								  nvSize);       
	// Get path to custom dll	
	nResult=UseDLL( szQConsolePath^"qcinst.dll" );
	if(nResult < 0)then
   		MessageBox( "qcinst.dll FAILED - ", INFORMATION );
    endif;
    nHwnd = GetWindowHandle (HWND_INSTALL);
	//////////////////////////////////////
	//DO NOT DELETE.  The below code will
	//initiate the uninstallation process.
	UninstInitialize(nHwnd);
	UninstUnInitialize(nHwnd);
	UnUseDLL( szQConsolePath ^ "qcinst.dll" ) ;  
	RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
    RegDBDeleteValue(RUNONCE_KEY, "QSERVERPS");  
    RegDBSetDefaultRoot (HKEY_CLASSES_ROOT);	
	//////////////////////////////////////
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function:  HandleVirusDefs
//
//  Purpose:  Perform Virus Def install handling
//
///////////////////////////////////////////////////////////////////////////////
function HandleVirusDefs(hMSI)
    NUMBER nResult, nDisk;
    BOOL bResult;
begin 
	// initialize the return value
    bResult = TRUE;

    // try to get a target directory for the virus definitions component
    if (FALSE = GetDefsDirectory(INSTALLDIR, szDefUtilsDir)) then
    	bResult = FALSE;
    endif;
    
    nvHawkingStatus = HAWKING_TEMP_DIR_ONLY;
	
	//JA Set the target path for the VirusDefs Component    
    MsiSetTargetPath(hMSI,"DEFUTILSDIR",szDefUtilsDir);
    
    return 0;

end;

///////////////////////////////////////////////////////////////////////////////
//
// Function:  CopyVirusDefs
//
//  Purpose:  Perform Virus Def install handling
//
///////////////////////////////////////////////////////////////////////////////
function CopyVirusDefs(hMSI)
NUMBER nResult;
begin

    // copy the virus definitions to their final location
    //nResult = CopyVirusDefinitionFiles(szDefUtilsDir);
    nResult = CopyVirusDefinitionFiles(szDefUtilsDir);
    nvHawkingStatus = HAWKING_USING_DEFS;  
end;  

///////////////////////////////////////////////////////////////////////////////
//
// Function:  CheckInstallDir
//
//  Purpose:  Checks the user selected directory
///////////////////////////////////////////////////////////////////////////////
//	05/22/02 - John Lenz
///////////////////////////////////////////////////////////////////////////////
function CheckInstallDir(hMSI) 
begin 
	return CheckDir( hMSI, "INSTALLDIR" );
end;

function CheckBrowseDir( hMSI )
	STRING szProperty;
    LONG lBuf;
begin    
	MsiGetProperty(hMSI,"_BrowseProperty", szProperty, lBuf);

	return CheckDir( hMSI, szProperty );
end;

function CheckDir(hMSI, szProperty) 
	STRING szPath;
	STRING szQcinstDLL;
	NUMBER lTargetPathLength;
    LONG lBuf;
    NUMBER i;
    NUMBER nChar;
    BOOL bBadChar;    
begin 
	//create and set the invalid property in the dialog to false
	MsiSetProperty(hMSI,"INVALIDINSTALLDIR","0");
    
	// get the value set by the user
	MsiGetProperty(hMSI,szProperty, szPath, lBuf);

	// SprintfBox (SEVERE, "DEBUG", "PROPERTY = " + szPath);
 
    lTargetPathLength = StrLength(szPath);
    if ( lTargetPathLength > 100 ) then
		SprintfBox (SEVERE, @ID_TITLE_ERR_DRIVE, @ID_ERROR_PATH_TOOLARGE);    	
     	MsiSetProperty(hMSI,"INVALIDINSTALLDIR","1");
     	return 0;
    endif;	
    
    // don't allow an install at the root "c:\" but "c:\x" is ok.
    if ( lTargetPathLength < 4 ) then
    	SprintfBox (SEVERE, @ID_PRODUCT_NAME, @ID_ERROR_PATH_TOO_SHORT);
     	MsiSetProperty(hMSI,"INVALIDINSTALLDIR","1");
     	return 0;
    endif;	
    
    // Make sure that the user has specified a fixed drive.
    // No installs to netwrk shares, mapped network drives
    // or removable drives.
    GetSystemInfo( DRIVE, i, szPath );
    if( i != IS_FIXED ) then
    	SprintfBox( SEVERE, @ID_PRODUCT_NAME, @ID_ERROR_FIXED_DRIVE_ONLY );
     	MsiSetProperty(hMSI,"INVALIDINSTALLDIR","1");
     	return 0;
    endif;
    
    bBadChar = FALSE;
    for i = 0 to (lTargetPathLength-1)
         nChar = szPath[i];
         // Check for characters above "~", less than " ", 
         // or equal "?".  The last because as much as InstallShield
         // claims to support UNICODE, they are really using ANSI
         // characters outside the current code page are converted to 
         // "?".  
         if ( (nChar > 126) || (nChar<32) || (nChar=63)) then
            bBadChar = TRUE;
         endif;
    endfor;
    
    if (bBadChar = TRUE) then
    	SprintfBox (SEVERE, @ID_PRODUCT_NAME, @ID_ERROR_PATH_INVALID);
     	MsiSetProperty(hMSI,"INVALIDINSTALLDIR","1");
     	return 0;
    endif;

    // Make sure that the user has write privileges to the directory
    FindAllFiles (SRCDIR, "\\qcinst.dll", szQcinstDLL, RESET);
    UseDLL( szQcinstDLL );
 
    // Call the function 
    i = IsFolderWriteable( szPath );

    // Unload the DLL	
    UnUseDLL( szQcinstDLL );
    
    //Check results
    if( i = 0 ) then
        // Can't write to the install dir, alert user and bail out of the install
        SprintfBox( SEVERE, @ID_PRODUCT_NAME, @ID_READ_ONLY_FOLDER );
     	MsiSetProperty( hMSI, "INVALIDINSTALLDIR", "1" );
     	return 0;
    endif;
 	                                                          
	return 0;
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function:  DeleteIfRegKeyIsEmpty
//
//  Purpose:  Checks the caller's key to see if it contains
//            any keys or values, then deletes it if it's empty.
///////////////////////////////////////////////////////////////////////////////
//	05/24/02 - Rich Sutton
///////////////////////////////////////////////////////////////////////////////
function DeleteIfRegKeyIsEmpty( szKeyName )
	BOOL bIsEmpty;
	LIST listID;
begin
	bIsEmpty = TRUE;
	
	// First, check for any keys         
	listID = ListCreate(STRINGLIST);
	if( RegDBQueryKey( szKeyName, REGDB_KEYS, listID ) = 0 ) then
		if( ListCount( listID ) > 0 ) then
			bIsEmpty = FALSE;
		endif;
	endif;
	ListDestroy( listID );
	
	// Next, check for any values
	if( bIsEmpty = TRUE ) then
		listID = ListCreate(STRINGLIST);
		if( RegDBQueryKey( szKeyName, REGDB_NAMES, listID ) = 0 ) then
			if( ListCount( listID ) > 0 ) then
				bIsEmpty = FALSE;
			endif;
		endif;
		ListDestroy( listID );
	endif;

	// If it's empty - delete it.	
	if( bIsEmpty = TRUE ) then
		RegDBDeleteKey( szKeyName );
	endif;
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: AMSSetup
//
//  Purpose: This function makes the registry entries for this setup.
//
///////////////////////////////////////////////////////////////////////////////
function AMSSetup(hMSI)
	STRING szExecutable,szAMSFolder,svValue;
	STRING szAMSInstallStatus[MAX_AMSINSTALL_STRLEN + 1];
	NUMBER nResult, nAMSStatusLen, nvType, nvSize;
	BOOL bAMSIsAlreadyThereDontReboot;
begin

    szExecutable = AMS_INSTALL_DLL ;
    LongPathToShortPath( szExecutable );
    szAMSFolder = INSTALLDIR ^ AMS_INSTALLBIN_PATH;
    LongPathToShortPath( szAMSFolder );
    ChangeDirectory( szAMSFolder );

    if( 0 != UseDLL( szExecutable ) ) then
        MessageBox( "AMSSetup: " + @ID_ERROR_LOADING_AMSINSTDLL, WARNING );
    else
        RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
        bAMSIsAlreadyThereDontReboot = TRUE;
        if ( 0 = RegDBGetKeyValueEx(SYMANTEC_INSTALLED_APPS_KEY, "AMSUsageCount", nvType, svValue, nvSize)) then
                bAMSIsAlreadyThereDontReboot = FALSE;
        endif;
        nAMSStatusLen = MAX_AMSINSTALL_STRLEN ;
        nResult = InstallAMS2( szAMSFolder, AMS_PRODUCT_NAME, szAMSInstallStatus, nAMSStatusLen, AMS_FLAGS_CONSOLE | AMS_FLAGS_CLIENT, TRUE );
        UnUseDLL( szExecutable );

        // This API now returns 0x40000000 instead of 0x80000000
        if( 1073741824 = nResult) then
            if(bAMSIsAlreadyThereDontReboot)then
                MsiSetProperty(hMSI, "REBOOT","Force");
            endif;
        else
            if ( 0 != nResult ) then
                MessageBox( @ERROR_AMS_INSTALL  + szAMSInstallStatus, INFORMATION );
            endif;

        endif;
    endif;

    ChangeDirectory( SRCDIR );

    // Update registry indicating AMS console has been installed
    RegDBSetDefaultRoot (HKEY_LOCAL_MACHINE);
    RegDBSetKeyValueEx( SYMANTEC_QCONSOLE_KEY, AMSCONSOLEINSTALLED_VALUE, REGDB_NUMBER, "1", -1 );
    RegDBSetKeyValueEx( SYMANTEC_QCONSOLE_KEY, AMSINSTALLPATH_VALUE, REGDB_STRING, szAMSFolder, -1);

end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: UnAMSSetup
//
//  Purpose: This function will uninstall AMS.
//
///////////////////////////////////////////////////////////////////////////////
function UnAMSSetup(hMSI)
	STRING szExecutable,szAMSFolder;
	STRING szAMSInstallStatus[MAX_AMSINSTALL_STRLEN + 1];
	NUMBER nResult, nAMSStatusLen;
begin
	szExecutable = AMS_INSTALL_DLL ;
    LongPathToShortPath( szExecutable );
    szAMSFolder = INSTALLDIR ^ AMS_INSTALLBIN_PATH;
    LongPathToShortPath( szAMSFolder );
    ChangeDirectory( szAMSFolder );

    if( 0 != UseDLL( szExecutable ) ) then
        MessageBox( "UnAMSSetup: " + @ID_ERROR_LOADING_AMSINSTDLL, WARNING );
    else
        nAMSStatusLen = MAX_AMSINSTALL_STRLEN ;
        nResult = InstallAMS2( szAMSFolder, AMS_PRODUCT_NAME, szAMSInstallStatus, nAMSStatusLen, AMS_FLAGS_CONSOLE | AMS_FLAGS_CLIENT, FALSE );
        UnUseDLL( szExecutable );

        // This API now returns 0x40000000 instead of 0x80000000
        if( 2147483648 = nResult ) then
            MsiSetProperty(hMSI, "REBOOT","Force");
        else
            if ( 0 != nResult ) then
                MessageBox( @ERROR_AMS_INSTALL  + szAMSInstallStatus, INFORMATION );
            endif;

        endif; 
        
        // The reboot return value is never returned for uninstall, but it is always needed.
        MsiSetProperty(hMSI, "REBOOT","Force");
        
    endif;
    ChangeDirectory( SRCDIR );

    // Update registry indicating AMS console has been removed
    RegDBSetDefaultRoot (HKEY_LOCAL_MACHINE);
    RegDBDeleteValue( SYMANTEC_QCONSOLE_KEY, AMSCONSOLEINSTALLED_VALUE );
    RegDBDeleteValue( SYMANTEC_QCONSOLE_KEY, AMSINSTALLPATH_VALUE );
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: UnAMSSetup_RB
//
//  Purpose: This function will re-install AMS.
//
///////////////////////////////////////////////////////////////////////////////
function UnAMSSetup_RB(hMSI)
begin
        AMSSetup(hMSI);
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: AMSSetup_RB
//
//  Purpose: This function will uninstall AMS during rollback.
//
///////////////////////////////////////////////////////////////////////////////
function AMSSetup_RB(hMSI)
begin
        UnAMSSetup(hMSI);
end;
 
///////////////////////////////////////////////////////////////////////////////
//
//  Function: IsNEC
//
//  Purpose: Set the ISNEC property
//
///////////////////////////////////////////////////////////////////////////////
function IsNEC(hMSI)
    STRING szUser32DLL;
    BOOL bRtnVal;
begin
	MsiSetProperty(hMSI,"ISNEC","0");

    szUser32DLL = SystemFolder ^ "USER32.DLL";
    if(UseDLL(szUser32DLL) = 0) then
        if ( User32.GetKeyboardType( 0 ) = 7 ) then
            if ( User32.GetKeyboardType( 1 ) > 3328 ) then
				MsiSetProperty(hMSI,"ISNEC","1");
            endif;
        endif;
        UnUseDLL(szUser32DLL);
    endif;

    return 0;
end; 

///////////////////////////////////////////////////////////////////////////////
//
//  Function: RegisterQServerPS
//
//  Purpose: registers qserverps
//
///////////////////////////////////////////////////////////////////////////////
function RegisterQServerPS(hMSI)
    STRING szExecutable;
    BOOL nResult;
begin
    // Register Qserverps.DLL
    szExecutable = " /s  \"" + INSTALLDIR^"qserverps.dll" + "\"";
  
    // Register Qserverps now...
    nResult = LaunchAppAndWait (SystemFolder ^ "regsvr32.EXE", szExecutable,WAIT);  
      
    // Register Qserverps on reboot (if it needs replacing).		
    RegDBSetDefaultRoot (HKEY_LOCAL_MACHINE);
    RegDBSetKeyValueEx( RUNONCE_KEY, "QSERVERPS", REGDB_STRING, SystemFolder ^ "regsvr32.EXE" + szExecutable, -1 );
    RegDBSetDefaultRoot (HKEY_CLASSES_ROOT);

    return 0;
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: HideUninstallCancelButton
// Purpose:  When removing the product via Add/Remove Programs,
//			 hide the cancel button on the MSI progress dialog
///////////////////////////////////////////////////////////////////////////////
//	07/16/02 - Joe Antonelli                                                                        
///////////////////////////////////////////////////////////////////////////////
function HideUninstallCancelButton(hMSI)
NUMBER	hRecord;
INT		iRet;
begin

	hRecord = MsiCreateRecord(3);

	if(hRecord)then
		MsiRecordSetInteger(hRecord,1,2);
		MsiRecordSetInteger(hRecord,2,0);
		iRet = MsiProcessMessage(hMSI,INSTALLMESSAGE_COMMONDATA,hRecord);
	endif;
	MsiCloseHandle(hRecord);

	return ERROR_SUCCESS;
	
end; 


 
// --- include script file section ---

