#include "stdafx.h"
#include "Qscon.h"
#import "qserver.tlb" no_namespace
#include "QSConsole.h"
#include "qcresult.h"
#include "dcomobject.h"
#include "macros.h"
#include "MultiSelDataObject.h"
#include "winsvc.h"
#include "qscommon.h"
#include "filenameparse.h"


///////////////////////////////////////////////////////////////////////////////
//
// Function name : CQSConsole::Initialize
//
// Description   : 
//
// Return type   : HRESULT 
//
// Argument      : LPUNKNOWN pUnknown
//
///////////////////////////////////////////////////////////////////////////////
// 2/3/99 - DBUCHES: Function created / header added 
///////////////////////////////////////////////////////////////////////////////
HRESULT CQSConsole::Initialize(LPUNKNOWN pUnknown)
{
	HRESULT hr = IComponentDataImpl<CQSConsole, CQSConsoleComponent >::Initialize(pUnknown);
	if (FAILED(hr))
		return hr;

	CComPtr<IImageList> spImageList;

	if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
	{
		ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
		return E_UNEXPECTED;
	}

    // 
    // Get namespace interface.
    // 
    if( FAILED( pUnknown->QueryInterface( IID_IConsoleNameSpace, (LPVOID*) &m_pNameSpace ) ) )
        {
        return E_UNEXPECTED;
        }

	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_QSCONSOLE_16));
	if (hBitmap16 == NULL)
		return S_OK;

	HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_QSCONSOLE_32));
	if (hBitmap32 == NULL)
		return S_OK;

	if (spImageList->ImageListSetStrip((long*)hBitmap16, 
		(long*)hBitmap32, 0, RGB(255, 0, 255)) != S_OK)
	{
		ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
		return E_UNEXPECTED;
	}
	return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
//
// Function name: CQSConsole::Notify
//
// Description  : 
//
// Return type  : STDMETHODIMP 
//
// Argument     : PDATAOBJECT lpDataObject
// Argument     : MMC_NOTIFY_TYPE event
// Argument     : long arg
// Argument     : long param
//
///////////////////////////////////////////////////////////////////////////////
// 3/21/99 - DBUCHES: Function created / header added 
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CQSConsole::Notify( 
    LPDATAOBJECT lpDataObject,
    MMC_NOTIFY_TYPE event,
    long arg,
    long param)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());    

    switch( event )
        {
        case MMCN_PROPERTY_CHANGE:
            {
            if( arg == TRUE && param )
                {
                CSnapInItem* pItem = (CSnapInItem*) param;
                return pItem->Notify(event, arg, param, this, NULL, CCT_SCOPE );
                }
            }
            break;

        case MMCN_EXPAND:
            if( S_FALSE == OnExpand( lpDataObject, arg, param ) )
                return S_OK;
            break;
        }
    // 
    // Return base class implementation
    // 
    return IComponentDataImpl<CQSConsole, CQSConsoleComponent>::Notify(
                                                                lpDataObject,
                                                                event,
                                                                arg,
                                                                param );
}



///////////////////////////////////////////////////////////////////////////////
//
// Function name: CQSConsole::CheckForExtensions
//
// Description  : 
//
// Return type  : BOOL 
//
// Argument     :  LPDATAOBJECT lpDataObject
// Argument     : long parentID
//
///////////////////////////////////////////////////////////////////////////////
// 3/20/99 - DBUCHES: Function created / header added 
///////////////////////////////////////////////////////////////////////////////
HRESULT CQSConsole::CheckForExtensions( LPDATAOBJECT lpDataObject, long parentID )
{
    HRESULT hr = S_OK;
    SCOPEDATAITEM *psdi;
    CSnapInItem* pItem;
    DATA_OBJECT_TYPES type;
    CString sServer;

    // 
    // This call will force the framework to check for snapins.
    // 
    GetDataClass( lpDataObject, &pItem, &type );

    // 
    // Get computer name from extension.
    //
    hr = ExtractComputerName( lpDataObject, sServer);

    // 
    // Check to see if we are extending someone.
    // 
    if( IS_EXTENSION_PRESENT( this, CExtendComputerManagement ) ||
        IS_EXTENSION_PRESENT( this, CExtendNSCStatic ) )
        {
        m_bExtension = TRUE;
        }

    if( FAILED( hr ) && m_bExtension) 
        {
        //
        // don't fail yet; we will bring up the AddServers
        // wizard later on selection
        // PAGBABI
        //
        hr = S_OK;
        }
        else
        {
        return E_FAIL;
        }

    // 
    // Add our main node as an extension.
    // 
    if( m_bExtension )
        {
        // 
        // Allocate new node.
        // 
        CQSConsoleData* pNode = new CQSConsoleData;
        pNode->m_pComponentData = this;

        //
        // if we deserialized from the stream and the
        // server name is blank, load the name and domain
        // from the static item
        // PAGBABI
        //
        if (sServer.IsEmpty())
        {
            CQSConsoleData* p = (CQSConsoleData*) m_pNode;
            sServer = p->GetServerName();
            pNode->SetDomainName( p->GetDomainName() );
        }

        pNode->SetServerName( sServer );

        // 
        // Add to list of nodes.
        // 
        m_aNodes.AddTail( pNode );

        pNode->GetScopeData( &psdi );
        psdi->mask |= SDI_PARENT;
        psdi->relativeID = parentID;
        hr = m_pNameSpace->InsertItem( psdi );
        if( FAILED( hr ) )
            return hr;
        }
    else
        {
        // 
        // No extensions here!
        // 
        return E_FAIL;
        }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// Function name: CQSConsole::OnExpand
//
// Description  : 
//
// Return type  : HRESULT 
//
// Argument     :  LPDATAOBJECT lpDataObject
// Argument     : long arg
// Argument     : long param
//
///////////////////////////////////////////////////////////////////////////////
// 4/19/99 - DBUCHES: Function created / header added 
///////////////////////////////////////////////////////////////////////////////
HRESULT CQSConsole::OnExpand( LPDATAOBJECT lpDataObject,
                  long arg,
                  long param )
{
    HRESULT hr = S_OK;
    BOOL bOurType = FALSE;
    GUID guidNode;
    DWORD dwBytesRead = 0;
    CComPtr< IStream > pStream;
    STGMEDIUM stg = { TYMED_HGLOBAL, 0 };
    FORMATETC format = { CSnapInItem::m_CCF_NODETYPE,
                         NULL,
                         DVASPECT_CONTENT,
                         -1,
                         TYMED_HGLOBAL };
    
    // 
    // Q: Which node is expanding?  Ours or someone else that we are 
    // extending.
    // 
    stg.hGlobal = GlobalAlloc( GHND, sizeof( GUID ) );
    if( stg.hGlobal == NULL )
        return E_OUTOFMEMORY;
    
    hr = lpDataObject->GetDataHere( &format, &stg );
    if( SUCCEEDED( hr ) )
        {
        hr = CreateStreamOnHGlobal( stg.hGlobal, FALSE, &pStream );
        if( SUCCEEDED( hr ) )
            {
            hr = pStream->Read( &guidNode, sizeof( GUID ), &dwBytesRead );
            if( SUCCEEDED( hr ) )
                {
                bOurType = IsEqualGUID( guidNode, *CQSConsoleData::m_NODETYPE );
                }
            }
        }

    GlobalFree( stg.hGlobal );
    
    if( bOurType )
        {
        // 
        // Initialize our AV Scanner.
        // 
        if( FAILED( m_AVScanner.Initialize() ) )
            {
            CString sTitle((LPCTSTR) IDS_ERROR_TITLE );
            CString sText((LPCTSTR) IDS_ERROR_NO_DEFS );
            MessageBox( GetActiveWindow(), sText, sTitle, MB_ICONSTOP | MB_OK );
            }
        }
    else if( arg )
        {
        //  
        // Check to see if we are an extension.
        // 
        if( FAILED( CheckForExtensions( lpDataObject, param ) ) )
            {
            ATLTRACE2(atlTraceSnapin, 0, _T("CQSConsole::OnExpand unrecognized extension.\n"));
            return S_OK;
            }
            
        return S_FALSE;
        }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function name: CQSConsoleData::ExtractComputerName
//
// Description  : 
//
// Return type  : HRESULT 
//
// Argument     : LPDATAOBJECT lpDataObject
//
///////////////////////////////////////////////////////////////////////////////
// 3/20/99 - DBUCHES: Function created / header added 
///////////////////////////////////////////////////////////////////////////////
HRESULT CQSConsole::ExtractComputerName( LPDATAOBJECT lpDataObject, CString& sSvr )
{
    HRESULT hr = S_OK;
    ULONG ulBytesRead;

    // 
    // Check to see if the computer name was specified to us.
    // 
    FORMATETC format = { CQSDataObject::m_CCF_COMPUTER_NAME,
                         NULL,
                         DVASPECT_CONTENT,
                         -1,
                         TYMED_HGLOBAL };
    STGMEDIUM stg = { TYMED_HGLOBAL, 0 };

    // 
    // Alloc a buffer for computer name.
    // 
    stg.hGlobal = GlobalAlloc( GHND, MAX_PATH );
    if( stg.hGlobal == NULL )
        return E_OUTOFMEMORY;

    if( SUCCEEDED( lpDataObject->GetDataHere( &format, &stg ) ) )
        {
        // 
        // Extract computer name from stream.
        // 
        CComPtr< IStream > pStream;
        hr = CreateStreamOnHGlobal( stg.hGlobal, FALSE, &pStream );
        if( SUCCEEDED( hr ) )
            {
            hr = pStream->Read( sSvr.GetBuffer(MAX_PATH), MAX_PATH, &ulBytesRead );
            sSvr.ReleaseBuffer();
            }
        }
    else
        hr = E_FAIL;

    // 
    // Cleanup
    // 
    GlobalFree( stg.hGlobal );

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
//
// Function name: CQSConsole::QueryDataObject
//
// Description  : 
//
// Return type  : STDMETHODIMP 
//
// Argument     : long cookie
// Argument     : DATA_OBJECT_TYPES type
// Argument     : LPDATAOBJECT  *ppDataObject
//
///////////////////////////////////////////////////////////////////////////////
// 4/19/99 - DBUCHES: Function created / header added 
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CQSConsole::QueryDataObject( long cookie,
                                          DATA_OBJECT_TYPES type,
                                          LPDATAOBJECT  *ppDataObject)
{
	ATLTRACE2(atlTraceSnapin, 0, _T("CQSConsole::QueryDataObject\n"));
	HRESULT hr = E_POINTER;
	
	ATLASSERT(ppDataObject != NULL);
	if (ppDataObject == NULL)
		ATLTRACE2(atlTraceSnapin, 0, _T("CQSConsole::QueryDataObject called with ppDataObject == NULL\n"));
	else
	{
		*ppDataObject = NULL;
		
		CSnapInItem* pItem = (CSnapInItem*) cookie;
		if (cookie == NULL)
			pItem = m_pNode;

		hr = pItem->GetDataObject(ppDataObject, type);
	}
	return hr;
}



///////////////////////////////////////////////////////////////////////////////
//
// Function name: CQSConsole::GetHelpTopic
//
// Description  : 
//
// Return type  : STDMETHODIMP 
//
// Argument     : LPOLESTR* lpCHM
//
///////////////////////////////////////////////////////////////////////////////
// 5/4/99 - DBUCHES: Function created / header added 
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CQSConsole::GetHelpTopic(LPOLESTR* lpCHM )
{
USES_CONVERSION;
    
    // 
    // Fetch full path to HTML help file.
    // 
    TCHAR szFileName[ MAX_PATH ];
    TCHAR szPath[ MAX_PATH ];
    GetModuleFileName( _Module.m_hInst, szFileName, MAX_PATH );
    CFileNameParse::GetFilePath( szFileName, szPath, MAX_PATH );
    lstrcat( szPath, _T("\\") );
    lstrcat( szPath, QCONSOLE_HELPFILE );

    // 
    // Allocate buffer for MMC
    // 
    *lpCHM = reinterpret_cast<LPOLESTR>
            (CoTaskMemAlloc((lstrlen( szPath ) + 1)* sizeof(wchar_t)) );

    if( *lpCHM == NULL )
        return E_OUTOFMEMORY;

    // 
    // Copy Data
    // 
    wcscpy( *lpCHM, T2OLE( szPath ) );
    
    return S_OK;
}









