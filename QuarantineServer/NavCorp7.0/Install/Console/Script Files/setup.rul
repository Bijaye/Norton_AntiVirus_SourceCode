////////////////////////////////////////////////////////////////////////////////
//
//  IIIIIII SSSSSS
//    II    SS                          InstallShield (R)
//    II    SSSSSS      (c) 1996-1998, InstallShield Software Corporation
//    II        SS      (c) 1990-1996, InstallShield Corporation
//  IIIIIII SSSSSS                     All Rights Reserved.
//
//
//  This code is generated as a starting setup template.  You should
//  modify it to provide all necessary steps for your setup.
//
//
//    File Name:  Setup.rul
//
//  Description:  InstallShield script
//
//     Comments:  This template script performs a basic setup. With minor
//                modifications, this template can be adapted to create
//                new, customized setups.
//
////////////////////////////////////////////////////////////////////////////////


// Include header files

    #include "sdlang.h"
    #include "sddialog.h"

////////////////////// string defines ////////////////////////////

	// Custom DLL
    #define UNINST_LOGFILE_NAME      "Uninst.isu"
	#define CUSTOM_DLLNAME           "NAVINSTNT.DLL"
	#define INSTALL_OPTIONS_FILE     "INSTOPTS.INI"
	#define IDB_WALLPAPER_BITMAP	 20001

	// Hawking tracking for aborting installs
	#define HAWKING_NO_ACTIVITY             0
	#define HAWKING_TEMP_DIR_ONLY           1
	#define HAWKING_USING_DEFS              2
	
	// Registry keys
	#define MICROSOFT_MANAGEMENT_CONSOLE	"SOFTWARE\\Microsoft\\MMC"
	#define SYMANTEC_INSTALLED_APPS_KEY     "\\Software\\Symantec\\InstalledApps"
	#define SERVICE_PACK2_HOTFIX_KEY        "\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\HOTFIX\\Q135707Q141239NTOSKRNLFIX"

//////////////////// installation declarations ///////////////////

// ----- DLL function prototypes -----

    // functions exported from "NAVInst" custom DLL
   	prototype   BOOL    NAVINSTNT.GetDefsDirectory(STRING, STRING);
	prototype   BOOL    NAVINSTNT.CopyVirusDefinitionFiles(STRING);
	prototype   NUMBER  NAVINSTNT.GetNT40ServicePack();
	prototype	BOOL	NAVINSTNT.PrepareSysDll(STRING);
	prototype   BOOL    NAVINSTNT.GetFileVersionString ( STRING, STRING );
	
	// functions exported from "Kernel32" DLL
	prototype   NUMBER  Kernel32.GetCurrentDirectory(NUMBER,POINTER);
	prototype   BOOL    Kernel32.SetCurrentDirectory(STRING);
	
	// functions exported from "User32" DLL
	prototype	INT		User32.GetKeyboardType(INT);

// ---- script function prototypes -----

    // generated by the Project Wizard
    prototype ShowDialogs();
    prototype MoveFileData();
    prototype HandleMoveDataError( NUMBER );
    prototype ProcessBeforeDataMove();
    prototype ProcessAfterDataMove();
    prototype SetupRegistry();
    prototype SetupFolders();
    prototype CleanUpInstall();
    prototype SetupInstall();
    prototype SetupScreen();
    prototype CheckRequirements();
    prototype DialogShowSdWelcome();
    prototype DialogShowSdLicense();
    prototype DialogShowSdAskDestPath();
    prototype DialogShowSdStartCopy();
    prototype DialogShowSdFinishReboot();
    prototype SetDialogBitmap( NUMBER );
    prototype MoveNonSharedFiles();
    prototype DoCopyMFC42DLLs();
    prototype DoCopyMsvcrtDll();
    prototype DoCopyMfc42Dll();
    prototype DoCopyMfc42uDll();
    prototype CompareFileVersions( STRING, STRING );

    // Hawking specific prototypes
	prototype SetupVirusDefs();
	prototype UpdateVirusDefs();
	prototype UpdateFilesFromArchive(STRING, STRING, STRING);
	prototype IsAcceptableNTServicePack(); // CMM -- 07/28/99
	prototype IsNEC();
	prototype HandleMMC();
	prototype ModifyUninstallString();
	prototype QConsoleInstalled();

    // ----- global variables ------

    // generated by the Project Wizard
    BOOL        bIsWindowsNT4, bIsWindowsNT351, bIsWindows98, bIsWindows95;
    BOOL        bIsShellExplorer, bInstallAborted, bIs32BitSetup;
    STRING      svDir;
    STRING      svName, svCompany, svSerial;
    STRING      svDefGroup;
    STRING      szAppPath;
    STRING      svSetupType;
    LIST        listStartCopy;

    // your global variables
    STRING		g_szAppPath;
    STRING		szTitle;
    STRING		szMsg;
    STRING		szDLL;
    STRING		szDefUtilsDir;
    STRING		szInstallOptsFile;
    NUMBER		nvMMCInstalled;
    NUMBER		nvHawkingStatus;

///////////////////////////////////////////////////////////////////////////////
//
//   MAIN PROGRAM
//
//      The setup begins here by hiding the visible setup
//      window.  This is done to allow all the titles, images, etc. to
//      be established before showing the main window.  The setup is
//      then performed in a series of calls to script defined functions,
//      with error checking at each step.
//
///////////////////////////////////////////////////////////////////////////////
program
    Disable( BACKGROUND );

    CheckRequirements();

	// Do other pre-install processing
    SetupInstall();

    // Check for an installed MS Management Console (MMC)
    HandleMMC();

    SetupScreen();

    if (ShowDialogs()<0) goto end_install;

    if (ProcessBeforeDataMove()<0) goto end_install;

    if (MoveFileData()<0) goto end_install;

    if (ProcessAfterDataMove()<0) goto end_install;

    if (SetupRegistry()<0) goto end_install;

    if (SetupFolders()<0) goto end_install;

    end_install:

    CleanUpInstall();

    // If an unrecoverable error occurred, clean up
    // the partial installation. Otherwise, exit normally.

    if (bInstallAborted) then
        abort;
    endif;

endprogram

///////////////////////////////////////////////////////////////////////////////
//
// Function:  ShowDialogs
//
//  Purpose:  This function manages the display and navigation of
//            the standard dialogs that exist in a setup.
//
///////////////////////////////////////////////////////////////////////////////
function ShowDialogs()
    NUMBER  nResult;

begin

    Dlg_Start:
    // beginning of dialogs label

    Dlg_SdWelcome:
    SetDialogBitmap(1);
    nResult = DialogShowSdWelcome();
    if (nResult = BACK) goto Dlg_Start;

    Dlg_SdLicense:
    nResult = DialogShowSdLicense();
    if (nResult = BACK) goto Dlg_SdWelcome;

    Dlg_SdAskDestPath:
    SetDialogBitmap(2);
    nResult = DialogShowSdAskDestPath();
    if (nResult = BACK) goto Dlg_SdLicense;

    return 0;

end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: ProcessBeforeDataMove
//
//  Purpose: This function performs any necessary operations prior to the
//           actual file transfer.
//
///////////////////////////////////////////////////////////////////////////////
function ProcessBeforeDataMove()
    STRING svLogFile, svCopiedFile;
    NUMBER nResult;
	STRING sResult;
begin

  // Create app information, uninstallation, and App Paths registry keys.

    InstallationInfo( @COMPANY_NAME, @PRODUCT_NAME, @PRODUCT_VERSION, @PRODUCT_KEY );

    svLogFile = UNINST_LOGFILE_NAME;

    nResult = DeinstallStart( svDir, svLogFile, @UNINST_KEY, 0 );
    if (nResult < 0) then
        MessageBox( @ERROR_UNINSTSETUP, WARNING );
    endif;

    szAppPath = TARGETDIR; // TO DO : if your application .exe is in a subfolder
                           // of TARGETDIR then add subfolder

    if ((bIs32BitSetup) && (bIsShellExplorer)) then
        RegDBSetItem( REGDB_APPPATH, szAppPath );
        RegDBSetItem( REGDB_APPPATH_DEFAULT, szAppPath ^ @PRODUCT_KEY );
        RegDBSetItem( REGDB_UNINSTALL_NAME, @UNINST_DISPLAY_NAME );
    endif;

    // TO DO : any other tasks you want to perform before file transfer
    //
    // If you are installing self-registering files using the
    // batch method, remove the slashes from the line below:
    //
    Enable ( SELFREGISTERBATCH );

    // setup the target location for the virus definitions component
    SetupVirusDefs();

    // If MFC42.dll, mfc42u.dll or msvcrt.dll are readonly in system32 ..change their attributes
    if( 0 = GetFileInfo( WINSYSDIR ^ "mfc42.dll", FILE_ATTRIBUTE, nResult, sResult) ) then
    	if (FILE_ATTR_READONLY & nResult) then
    		//The file is READ-ONLY.
    		nResult = nResult & ~FILE_ATTR_READONLY ;
    		SetFileInfo( WINSYSDIR ^ "mfc42.dll", FILE_ATTRIBUTE, nResult ,"" );
    	endif;
    endif;
    if( 0 = GetFileInfo( WINSYSDIR ^ "mfc42u.dll", FILE_ATTRIBUTE, nResult, sResult) ) then
    	if (FILE_ATTR_READONLY & nResult) then
    		//The file is READ-ONLY.
    		nResult = nResult & ~FILE_ATTR_READONLY ;
    		SetFileInfo( WINSYSDIR ^ "mfc42u.dll", FILE_ATTRIBUTE, nResult ,"" );
    	endif;
    endif;
    if( 0 = GetFileInfo( WINSYSDIR ^ "msvcrt.dll", FILE_ATTRIBUTE, nResult, sResult) ) then
    	if (FILE_ATTR_READONLY & nResult) then
    		//The file is READ-ONLY.
    		nResult = nResult & ~FILE_ATTR_READONLY ;
    		SetFileInfo( WINSYSDIR ^ "msvcrt.dll", FILE_ATTRIBUTE, nResult ,"" );
    	endif;
    endif;

	// copy MFC42U.DLL and MFC42 to the TARGETDIR folder so that REGSVR32.EXE will work.
	VarSave(SRCTARGETDIR);
	SRCDIR = SUPPORTDIR;
	CopyFile("MFC42U.DLL", "MFC42U.DLL");
	CopyFile("MFC42.DLL", "MFC42.DLL");
	VarRestore(SRCTARGETDIR);
	return 0;
end;

///////////////////////////////////////////////////////////////////////////////
//
//  Function:  MoveFileData
//
//  Purpose:  This function handles the file transfer for
//            the setup.
//
///////////////////////////////////////////////////////////////////////////////
function MoveFileData()
    NUMBER nResult, nDisk;

begin

    nDisk = 1;

    SetStatusWindow( 0, "" );
	Disable(DIALOGCACHE);
    Disable(FEEDBACK_FULL);
    PlaceWindow(STATUS, CENTERED, 1, LOWER_LEFT);
    Enable( STATUS );
    StatusUpdate( ON, 100 );

    nResult = ComponentMoveData( MEDIA, nDisk, 0 );

    // copy over the "non-shared" files
    MoveNonSharedFiles();
	
	HandleMoveDataError( nResult );

    // copy the virus definitions to their final location
    nResult = CopyVirusDefinitionFiles(szDefUtilsDir);
    nvHawkingStatus = HAWKING_USING_DEFS;

    Disable( STATUS );

    return nResult;

end;


///////////////////////////////////////////////////////////////////////////////
//
// Function: HandleMoveDataError
//
//  Purpose: This function handles the error (if any) during the file transfer
//           operation.
//
///////////////////////////////////////////////////////////////////////////////
function HandleMoveDataError( nResult )
    STRING szErrMsg, svComponent , svFileGroup , svFile;

begin

    svComponent = "";
    svFileGroup = "";
    svFile = "";

    switch (nResult)
        case 0:
            return 0;
        default:
            ComponentError ( MEDIA , svComponent , svFileGroup , svFile , nResult );
            szErrMsg = @ERROR_MOVEDATA  + "\n\n" +
                @ERROR_COMPONENT + " " + svComponent + "\n" +
                @ERROR_FILEGROUP + " " + svFileGroup + "\n" +
                @ERROR_FILE      + " " + svFile;
            SprintfBox( SEVERE, @TITLE_CAPTIONBAR, szErrMsg, nResult );
            bInstallAborted = TRUE;
            return nResult;
    endswitch;

end;


///////////////////////////////////////////////////////////////////////////////
//
// Function: MoveNonSharedFiles
//
//  Purpose: This function moves any "non-shared" files (files for which we do not
//           want any usage counts maintained and we want full control over) to
//           their final location, and removes from the TARGETDIR.
//
///////////////////////////////////////////////////////////////////////////////

function    MoveNonSharedFiles()
    BOOL    bResult;
    NUMBER  nResult;
    STRING  szCommand;
    STRING	szGRCFile;
begin

    // disable logging so InstallShield won't try to remove these files during
    // uninstall
    Disable(LOGGING);

    VarSave(SRCTARGETDIR);

    // move the windows system NS ("non-shared") files over and delete them from TARGETDIR
    SRCDIR = SUPPORTDIR;
    TARGETDIR = WINSYSDIR;

    DoCopyMFC42DLLs();
    DoCopyMsvcrtDll();

    TARGETDIR = SUPPORTDIR;
    nResult = DeleteFile("mfc42.dll");
	nResult = DeleteFile("mfc42u.dll");
    nResult = DeleteFile("msvcrt.dll");

    VarRestore(SRCTARGETDIR);

end_move:
    // re-enable logging
    Enable(LOGGING);

end;    // MoveNonSharedFiles


//////////////////////////////////////////////////////////////////////////
//
// Function:    DoCopyMFC42DLLs()
//
// Description:
//  Does manual version-checking on MFC42(u).DLL, and copies our files to
//  WINSYSDIR if the version is the same or newer than the existing files,
//  or if the files aren't on the system yet.
//
// Input:
//  Nothing.
//
// Returns:
//  Nothing.
//
// Note:
//  This function is here because we've had reports of newer DLLs being
//  overwritten by our install.  I've implemented this with the assumption
//  that InstallShield's version checking ain't working right (that's why
//  I'm not using VerCompare).
//
//////////////////////////////////////////////////////////////////////////
function DoCopyMFC42DLLs()
    STRING szOurMFCVer;
    STRING szExistingMFCVer;
    STRING szOurSysVer;
    STRING szExistingSysVer;
    NUMBER nDummy;
    BOOL   bDoCopy;
begin
    // Get version of the existing MFC42.DLL.  If this call fails then there
    // is no existing copy of the file so we can install ours.

    if ( !GetFileVersionString ( WINSYSDIR  ^ "mfc42.dll",
                                  szExistingMFCVer ) ) then
    	DoCopyMfc42Dll();
    else

    // Get the version of our file.
    ComponentFileInfo ( MEDIA, "System Files",
                        "System Files\\mfc42.dll",
                        COMPONENT_INFO_VERSIONSTR, nDummy,
                        szOurMFCVer );
	endif;

    // Compare the files' versions.  If the existing file is newer, then we
    // don't copy ours to the system dir.

    if ( -1 == CompareFileVersions ( szExistingMFCVer, szOurMFCVer ) )
    then
        DoCopyMfc42Dll();
    endif;

    // Get version of the existing MFC42u.DLL.  If this call fails then there
    // is no existing copy of the file so we can install ours.

    if ( !GetFileVersionString ( WINSYSDIR  ^ "mfc42u.dll",
                                  szExistingMFCVer ) ) then
    	DoCopyMfc42uDll();
    else

    // Get the version of our file.
    ComponentFileInfo ( MEDIA, "System Files",
                        "System Files\\mfc42u.dll",
                        COMPONENT_INFO_VERSIONSTR, nDummy,
                        szOurMFCVer );
	endif;

    // Compare the files' versions.  If the existing file is newer, then we
    // don't copy ours to the system dir.

    if ( -1 == CompareFileVersions ( szExistingMFCVer, szOurMFCVer ) )
    then
        DoCopyMfc42uDll();
    endif;

end;


///////////////////////////////////////////////////////////////////////////////
//
// Function: DoCopyMfc42Dll()
//
//  Purpose: The purpose of this function is to copy over MFC42.DLL
//
///////////////////////////////////////////////////////////////////////////////
function DoCopyMfc42Dll()

begin

	PrepareSysDll ( WINSYSDIR ^ "mfc42.dll" );
	XCopyFile("mfc42.dll", "", COMP_UPDATE_VERSION | COMP_UPDATE_SAME | LOCKEDFILE);

end;


///////////////////////////////////////////////////////////////////////////////
//
// Function: DoCopyMfc42Dll()
//
//  Purpose: The purpose of this function is to copy over MFC42.DLL
//
///////////////////////////////////////////////////////////////////////////////
function DoCopyMfc42uDll()

begin

	PrepareSysDll ( WINSYSDIR ^ "mfc42u.dll" );
	XCopyFile("mfc42u.dll", "", COMP_UPDATE_VERSION | COMP_UPDATE_SAME | LOCKEDFILE);

end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: DoCopyMsvcrtDll()
//
//  Purpose: The purpose of this function is to copy over the MS C-runtime
// library to the system dir much like the mfc42.dll.
//
///////////////////////////////////////////////////////////////////////////////

function	DoCopyMsvcrtDll()
    STRING szOurSysVer;
    STRING szExistingSysVer;
    NUMBER nDummy;
    BOOL   bDoCopy;
begin
    bDoCopy = TRUE;

    // Get version of the existing MFC42U.DLL.  If this call fails then there
    // is no existing copy of the file so we can install ours.

    if ( ! GetFileVersionString ( WINSYSDIR  ^ "msvcrt.dll",
                                  szExistingSysVer ) )
        goto docopy2;

    // Get the version of our file.
    ComponentFileInfo ( MEDIA, "System Files",
                        "System Files\\msvcrt.dll",
                        COMPONENT_INFO_VERSIONSTR, nDummy,
                        szOurSysVer );

    // Compare the files' versions.  If the existing file is newer, then we
    // don't copy ours to the system dir.

    if ( 1 == CompareFileVersions ( szExistingSysVer, szOurSysVer ) )
    then
        bDoCopy = FALSE;
    endif;

docopy2:
    if ( bDoCopy )
    then
    	PrepareSysDll( WINSYSDIR ^ "msvcrt.dll" );
        XCopyFile("msvcrt.dll", "", COMP_UPDATE_VERSION | COMP_UPDATE_SAME | LOCKEDFILE);
    endif;
end;


///////////////////////////////////////////////////////////////////////////////
//
// Function: ProcessAfterDataMove
//
//  Purpose: This function performs any necessary operations needed after
//           all files have been transferred.
//
///////////////////////////////////////////////////////////////////////////////
function ProcessAfterDataMove()
    STRING szReferenceFile, szMsg, svUpdatedFilename;

begin

    // TO DO : update self-registered files and other processes that
    //        should be performed after the files have been transferred.
    //
    // If you are installing self-registering files using the
    // batch method, remove the slashes from the lines below:
    //

    if Do ( SELFREGISTRATIONPROCESS ) < 0 then
    	szMsg = "File(s) failed to self-register: \n" + ERRORFILENAME;
    	MessageBox (szMsg, WARNING);
    endif;
	
	// Delete the superfluous key created by the call to InstallationInfo()
	RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
	RegDBDeleteKey("SOFTWARE\\Symantec\\Norton AntiVirus Quarantine Console");

    // DeinstallSetReference specifies a file to be checked before
    // uninstallation. If the file is in use, uninstallation will not proceed.

    szReferenceFile = svDir ^ @PRODUCT_KEY; // TO DO : If your file is in a
                                            // subfolder of svDir add that here
    DeinstallSetReference( szReferenceFile );

    // Update virus defs from external archive.
    UpdateVirusDefs();

    return 0;
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: SetupRegistry
//
//  Purpose: This function makes the registry entries for this setup.
//
///////////////////////////////////////////////////////////////////////////////
function SetupRegistry()
    NUMBER nResultCreateKeys;
    NUMBER nResultSetKeyPath;
    NUMBER nResultSetKeyLang;
    NUMBER nvType;
    NUMBER nvSize;
    NUMBER nUsgCnt;
    STRING szKey;
    STRING szValue;
    STRING szValueName;
    STRING svValueData;

begin

    // TO DO : Add all your registry entry keys here.
    // Call registry functions and/or create keys from
    // the InstallShield IDE's Resources pane.

    CreateRegistrySet( "" );

   	RegDBSetDefaultRoot( HKEY_LOCAL_MACHINE );
   	
  	RegDBCreateKeyEx ( "SOFTWARE\\Symantec\\Norton AntiVirus\\Qsconsole", "" );
	
   	RegDBSetKeyValueEx("SOFTWARE\\Symantec\\Norton AntiVirus\\Qsconsole",
    				   "InstallPath", REGDB_STRING, svDir, -1);

    RegDBSetKeyValueEx("SOFTWARE\\Symantec\\Norton AntiVirus\\Qsconsole",
           					   "Language", REGDB_STRING, "English", -1);
           					
    // [HKEY_LOCAL_MACHINE\SOFTWARE\Symantec\InstalledApps]
    RegDBSetKeyValueEx(SYMANTEC_INSTALLED_APPS_KEY, @INSTAPP_VALUE, REGDB_STRING,
    				   TARGETDIR, -1);
    				
    Disable(LOGGING);

    szKey = SYMANTEC_INSTALLED_APPS_KEY;
    RegDBCreateKeyEx(szKey, "");

    // Process the VP6UsageCount Key.
    szValueName = "VP6UsageCount";

    if( 0 = RegDBGetKeyValueEx( szKey, szValueName, nvType, svValueData, nvSize ) ) then
   		StrToNum( nUsgCnt, svValueData );
   		// increment the usage count.
   		nUsgCnt = nUsgCnt + 1;
   		NumToStr( szValue, nUsgCnt );
   		// set the new value.
   		RegDBSetKeyValueEx( szKey, szValueName, REGDB_NUMBER, szValue, -1 );
   	else
   		// The key doesn't exist so create it and give it a usage count of 1.
   		RegDBSetKeyValueEx( szKey, szValueName, REGDB_NUMBER, "1", -1 );
   	endif;
   	
    Enable(LOGGING);
				
    ModifyUninstallString();

    return nResultCreateKeys;
 end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: SetupFolders
//
//  Purpose: This function creates all the folders and shortcuts for the
//           setup.  This includes program groups and items for Windows 3.1.
//
///////////////////////////////////////////////////////////////////////////////
function SetupFolders()
    NUMBER nResult;

begin


    // TO DO : Add all your folders (or program groups) along with shortcuts (or
    // program items). Call CreateProgramFolder and AddFolderIcon, and/or create
    // shortcuts etc. from the InstallShield IDE's Resources pane.
    //
    // Note : for 16-bit setups you should add an uninstaller icon pointing to
    //        your log file.  Under 32-bit this is automatically done by Windows.

    nResult = CreateShellObjects( "" );

    return nResult;
 end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: CleanUpInstall
//
//  Purpose: This cleans up the setup.  Anything that should
//           be released or deleted at the end of the setup should
//           be done here.
//
///////////////////////////////////////////////////////////////////////////////
function CleanUpInstall()

begin

    ListDestroy( listStartCopy );

    if (bInstallAborted) then
        return 0;
    endif;

	SetDialogBitmap(3);
    DialogShowSdFinishReboot();

    if (BATCH_INSTALL) then // ensure locked files are properly transferred
        CommitSharedFiles(0);
    endif;

    return 0;
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: SetupInstall
//
//  Purpose: This will initialize the setup.  Any general initialization
//           needed for the installation should be performed here.
//
///////////////////////////////////////////////////////////////////////////////
function SetupInstall()

	NUMBER nResult;

begin

    Enable( CORECOMPONENTHANDLING );

    bInstallAborted = FALSE;
    szInstallOptsFile = SUPPORTDIR ^ INSTALL_OPTIONS_FILE;

    //  Create list of end user selections to be displayed by DialogShowSdStartCopy()

    listStartCopy = ListCreate(STRINGLIST);

    ListAddString( listStartCopy, "Place the summary here.", AFTER );

    //
    // The following directory structure is used for now until
    // I can get location of the installed NAV directory
    //
    svDir = PROGRAMFILES ^ @COMPANY_NAME ^ @NAV_QUARANTINE ^ @NAV_QUARANTINE_CONSOLE;

    TARGETDIR  = svDir;

    // load the custom DLL
    szDLL = SUPPORTDIR ^ CUSTOM_DLLNAME;
    if (0 != UseDLL(szDLL)) then
        if (MODE = SILENTMODE) then
            abort;
        else
            MessageBox(@ERROR_LOADING_CUSTOM_DLL, SEVERE);
            abort;
        endif;
    endif;

    // if the target system is NT4.0 running service pack 2, alert the user to upgrade
    if (2 = GetNT40ServicePack()) then
        // set the default root
        RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);

        nResult = RegDBKeyExist(SERVICE_PACK2_HOTFIX_KEY);
        // If Service pack 2 is present, abort if the user does not have the hotfix.
        if (1 != nResult) then
            if (MODE = SILENTMODE) then
                abort;
            else
                MessageBox(@ERROR_NT40_SERVICE_PACK2, SEVERE);
                abort;
            endif;
        endif;
    endif;


    SdProductName( @PRODUCT_NAME );

    Enable( DIALOGCACHE );

    return 0;
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function:  SetupScreen
//
//  Purpose:  This function establishes  the screen look.  This includes
//            colors, fonts, and text to be displayed.
//
///////////////////////////////////////////////////////////////////////////////

function    SetupScreen()
begin

    Disable ( BACKGROUND );             // Hide the changes we're about to make...

	PlaceBitmap ( ISUSER + ";255,0,255", IDB_WALLPAPER_BITMAP, 0, 0, UPPER_LEFT | BITMAPICON );
	SetColor ( BACKGROUND, RGB ( 255, 222, 1 ) );
	
    Enable(BACKGROUND);                 // Bam!  Here's your cool background

    Delay(1);

end;    // SetupScreen


///////////////////////////////////////////////////////////////////////////////
//
// Function:  CheckRequirements
//
//  Purpose:  This function checks all minimum requirements for the
//            application being installed.  If any fail, then the user
//            is informed and the setup is terminated.
//
///////////////////////////////////////////////////////////////////////////////
function CheckRequirements()
    NUMBER  nvDx, nvDy, nvResult;
    STRING  svResult;

begin

    bIsShellExplorer = FALSE;
    bIsWindowsNT4    = FALSE;
    bIsWindowsNT351  = FALSE;
    bIsWindows95     = FALSE;
    bIsWindows98     = FALSE;

    // Check screen resolution.
    GetExtents( nvDx, nvDy );

    if (nvDy < 480) then
        MessageBox( @ERROR_VGARESOLUTION, WARNING );
        abort;
    endif;

    // Set 'setup' operation mode
    bIs32BitSetup = TRUE;
    GetSystemInfo( ISTYPE, nvResult, svResult );
    if (nvResult = 16) then
        bIs32BitSetup = FALSE; // running 16-bit setup
        return 0; // no additional information required
    endif;

    // --- 32-bit testing after this point ---

    // Determine the target system's operating system.
    GetSystemInfo( OS, nvResult, svResult );

    if (nvResult = IS_WINDOWSNT) then
        // Check to see if OS is Windows NT 4.0 or Windows NT 3.51,
        // and if the shell being used is the Explorer shell.
        if (GetSystemInfo( WINMAJOR, nvResult, svResult ) = 0) then
            if ( ((nvResult = 4) && IsAcceptableNTServicePack()) || (nvResult > 4) ) then
                bIsShellExplorer = TRUE;
                bIsWindowsNT4 = TRUE;
            else
          	 	szTitle = @TITLE_CAPTIONBAR;
    			szMsg = @ERROR_INVALID_OS;
    			// Not running NT4 SP3, alert user and bail out of the install
    			SprintfBox(SEVERE, szTitle, szMsg);
    			abort;
            endif;
        endif;
    elseif (nvResult = IS_WINDOWS9X) then
        szTitle = @TITLE_CAPTIONBAR;
    	szMsg = @ERROR_INVALID_OS;
    	// Not running NT4, alert user and bail out of the install
    	SprintfBox(SEVERE, szTitle, szMsg);
    	abort;
    endif;

    // Make sure we're not running on an NEC box
    if(IsNEC()) then
    	szTitle = @TITLE_CAPTIONBAR;
    	szMsg = @ERROR_NEC;
    	// Running on NEC, alert user and bail out of the install
    	SprintfBox(SEVERE, szTitle, szMsg);
    	abort;
    endif;

    // Warn user if QConsole is already installed.
    if(QConsoleInstalled()) then
    	if(AskYesNo(@MSG_ALREADYINSTALLED, NO) = NO) then
    		abort;
    	endif;
    endif;
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: DialogShowSdWelcome
//
//  Purpose: This function handles the standard welcome dialog.
//
//
///////////////////////////////////////////////////////////////////////////////
function DialogShowSdWelcome()
    NUMBER nResult;
    STRING szTitle, szMsg;

begin

    szTitle = "";
    szMsg   = "";
    nResult = SdWelcome( szTitle, szMsg );

    return nResult;
end;


///////////////////////////////////////////////////////////////////////////////
//
// Function: DialogShowSdLicense
//
//  Purpose: This function displays the license agreement dialog.
//
//
///////////////////////////////////////////////////////////////////////////////
function DialogShowSdLicense()
    NUMBER nResult;
    STRING szTitle, szMsg, szQuestion, szLicenseFile;

begin

    szLicenseFile = SUPPORTDIR ^ "license.txt";
    szTitle    = "";
    szMsg      = "";
    szQuestion = "";
    nResult    = SdLicense( szTitle, szMsg, szQuestion, szLicenseFile );

    return nResult;
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: DialogShowSdAskDestPath
//
//  Purpose: This function asks the user for the destination folder.
//
///////////////////////////////////////////////////////////////////////////////
function DialogShowSdAskDestPath()
    NUMBER nResult;
    STRING szTitle, szMsg;

begin

    szTitle = "";
    szMsg   = "";
    nResult = SdAskDestPath( szTitle, szMsg, svDir, 0 );

    // if we're running in silent mode and the value fetched from the response
    // file is 'DEFAULT', then use the value we derived in SetupInstall()
    if ((MODE = SILENTMODE)  &&  ("DEFAULT" = svDir)) then
        svDir = g_szAppPath;
    endif;

    // set the target directory and global app path variable
    TARGETDIR = svDir;
    g_szAppPath = svDir;

    ComponentSetTarget(MEDIA, "<WINSYS_NS>", WINSYSDIR);

    return nResult;
end;

///////////////////////////////////////////////////////////////////////////////
//
//  Function: DialogShowSdStartCopy
//
//  Purpose: This function displays the dialog preceding the start of the
//           file transfer process.
//
///////////////////////////////////////////////////////////////////////////////
function DialogShowSdStartCopy()
    NUMBER nResult;
    STRING szTitle, szMsg;

begin

    szTitle = "";
    szMsg   = "";
    nResult = SdStartCopy( szTitle, szMsg, listStartCopy );

    return nResult;
end;


///////////////////////////////////////////////////////////////////////////////
//
//  Function: DialogShowSdFinishReboot
//
//  Purpose: This function will show the last dialog of the product.
//           It will allow the user to reboot and/or show some readme text.
//
///////////////////////////////////////////////////////////////////////////////
function DialogShowSdFinishReboot()
    NUMBER nResult, nDefOptions;
    STRING szTitle, szMsg1, szMsg2, szOption1, szOption2;
    NUMBER bOpt1, bOpt2;

begin

    if (!BATCH_INSTALL) then
        bOpt1 = FALSE;
        bOpt2 = FALSE;
        szMsg1 = @SETUP_COMPLETE;
        szMsg2 = "";
        szOption1 = "";
        szOption2 = "";
        nResult = SdFinish( szTitle, szMsg1, szMsg2, szOption1, szOption2, bOpt1, bOpt2 );
        return 0;
    endif;

    nDefOptions = SYS_BOOTMACHINE;
    szTitle     = "";
    szMsg1      = "";
    szMsg2      = "";
    nResult     = SdFinishReboot( szTitle, szMsg1, nDefOptions, szMsg2, 0 );

    return nResult;
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function: SetupVirusDefs
//
//  Purpose: This function initializes the virus definitions component with
//           a target directory.
//
///////////////////////////////////////////////////////////////////////////////

function    SetupVirusDefs()
    BOOL    bResult;
    NUMBER  nResult;
    STRING  szComponentName;

begin

    // initialize the return value
    bResult = TRUE;

    // try to get a target directory for the virus definitions component
    if (FALSE = GetDefsDirectory(TARGETDIR, szDefUtilsDir)) then
        bResult = FALSE;
        goto  Exit_Function;
    endif;

    nvHawkingStatus = HAWKING_TEMP_DIR_ONLY;

    // set the target directory for the virus definitions component
    szComponentName = "Virus Definitions Files";
    nResult = ComponentSetData(MEDIA, szComponentName, COMPONENT_FIELD_DESTINATION
                                                                , 0
                                                                , szDefUtilsDir);

    if (nResult < 0) then
        bResult = FALSE;
    endif;

Exit_Function:

    return (bResult);

end;    // SetupVirusDefs


///////////////////////////////////////////////////////////////////////////////
//
// Function:  UpdateVirusDefs
//
//  Purpose:  Retrieves virus specific path information & calls generic
//            function 'UpdateFilesFromArchive' to perform actual file
//            handling.
//
///////////////////////////////////////////////////////////////////////////////
function UpdateVirusDefs()
    NUMBER nType;
    NUMBER nSize;
    NUMBER nResult;
    STRING szIncomingDefDir;

begin
    // Get the virus defs location from registry.
    RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
    nType = REGDB_STRING;
    nResult = RegDBGetKeyValueEx(SYMANTEC_INSTALLED_APPS_KEY, "AVENGEDEFS", nType, szIncomingDefDir, nSize);

    if (nResult < 0) then
        return nResult;
    endif;

    // Put together the 'extract to' path.
    szIncomingDefDir = szIncomingDefDir ^ "INCOMING";
    return UpdateFilesFromArchive(szInstallOptsFile, @ADMIN_DEF_ARCHIVE, szIncomingDefDir);
end;


///////////////////////////////////////////////////////////////////////////////
//
// Function:  UpdateFilesFromArchive
//
//  Purpose:  Queries install options ini file for specified data file archive
//            and copies and extracts it to the specified location.
//
//     Args:  szIniFile - Fully qualifed name of install options file.
//            szSection - Ini section name to query.
//            szTargetDir - Final location for expanded files.
//
///////////////////////////////////////////////////////////////////////////////
function UpdateFilesFromArchive(szIniFile, szSection, szExtractTargetDir)
    STRING szSelfExtPgm;
    STRING szSelfExtDisk;
    STRING szSelfExtArgs;
    STRING szSrcRoot;
    STRING szDisk;
    STRING szMsg;
    STRING szIncomingDefDir;
    STRING szCurDir;
    STRING szOrgCurDir;
    NUMBER nSize;
    NUMBER nResult;
    NUMBER nPos;
    NUMBER nType;
begin
    // Make sure the ini file is where it needs to be.
    if (Is(FILE_EXISTS, szInstallOptsFile) <= 0) then
        return -1;
    endif;

    // Save the items this function may alter.
    VarSave(SRCTARGETDIR);
    nResult = GetCurrentDirectory(256, &szOrgCurDir);

    // Check the install options file to determine if the files
    // should be updated from an external, self extracting zip file.
    nResult = GetProfString(szIniFile, szSection, @ADMIN_SELF_EXTRACTOR, szSelfExtPgm);

    // If the entry could not be retrieved or is empty, exit.
    if ((nResult < 0) || ("" = szSelfExtPgm)) then
        // No error return value (-1) since this may fail legitimately.
        return 0;
    endif;

    TARGETDIR = SUPPORTDIR;

    GetProfString(szIniFile, szSection, @ADMIN_ARGUMENTS, szSelfExtArgs);
    GetProfString(szIniFile, szSection, @ADMIN_DISK, szSelfExtDisk);

    // Establish the current working directory
    SetCurrentDirectory(SRCDIR);
    szCurDir = SRCDIR;

    // Try the current source directory for the file.
    if (Is(FILE_EXISTS, szSelfExtPgm)) then
        goto DoFileCopy;
    else
        // Call Win32 to change directory using relative path.
        SetCurrentDirectory("..");
        SetCurrentDirectory(szSelfExtDisk);
        GetCurrentDirectory(256, &szCurDir);
        nResult = Is(FILE_EXISTS, szSelfExtPgm);
        SRCDIR = szCurDir;

        if (TRUE = nResult) then
            goto DoFileCopy;
        else
            Sprintf(szMsg, @DEF_UPDATE_MSG_FMT, szSelfExtPgm);
            nResult = EnterDisk(szMsg, szSelfExtPgm);
            if (OK = nResult) then
                // SRCDIR should be set by EnterDisk
                goto DoFileCopy;
            else
                goto UserCancel;
            endif;
        endif;
    endif;

DoFileCopy:
    nResult = XCopyFile(szSelfExtPgm, "", COMP_NORMAL);
    SetCurrentDirectory(szExtractTargetDir);
    LaunchAppAndWait(SUPPORTDIR ^ szSelfExtPgm, szSelfExtArgs, WAIT);

UserCancel:
    VarRestore(SRCTARGETDIR);
    nResult = SetCurrentDirectory(szOrgCurDir);
end;

///////////////////////////////////////////////////////////////////////////////
//
// Function:  SetDialogBitmap
//
//  Purpose:  Returns the filename of a bitmap whose number is passed in.
//            The filename is picked based on the color depth of the system.
//
///////////////////////////////////////////////////////////////////////////////

function SetDialogBitmap ( nBitmapNumber )

    STRING szFilename;

begin
    NumToStr ( szFilename, nBitmapNumber );

    szFilename = SUPPORTDIR ^ "install" + szFilename + ".bmp";

    DialogSetInfo( DLG_INFO_ALTIMAGE, szFilename, 0);
end;

///////////////////////////////////////////////////////////////////////////////
//
//  Function: IsAcceptableNTServicePack
//
//  Purpose: Returns TRUE if they have a service pack installed that we can accept
//		     returns FALSE otherwise.
//
///////////////////////////////////////////////////////////////////////////////
function IsAcceptableNTServicePack()
	BOOL bRtnVal;
	STRING svServicePack;
	NUMBER nvType, nvSize;
begin
	bRtnVal = TRUE;
	
	RegDBSetDefaultRoot( HKEY_LOCAL_MACHINE );
	
	if( RegDBGetKeyValueEx( "Software\\Microsoft\\Windows NT\\CurrentVersion", "CSDVersion", nvType,
							svServicePack, nvSize ) = 0 ) then
		// Insure that SP3 or greater is installed
        if (svServicePack = "") ||
           (svServicePack = "Service Pack 1") ||
           (svServicePack = "Service Pack 2") then
           bRtnVal = FALSE;
        endif;
	else
		bRtnVal = FALSE;	
	endif;
	
	return bRtnVal;
end;	

///////////////////////////////////////////////////////////////////////////////
//
//  Function: IsNEC
//
//  Purpose: Returns TRUE if the computer is an NEC computer.
//			 Added 7/30/99 -- CMM
//
///////////////////////////////////////////////////////////////////////////////
function IsNEC()
	STRING szUser32DLL;
	BOOL bRtnVal;
begin
	bRtnVal = FALSE;
	szUser32DLL = WINSYSDIR ^ "USER32.DLL";
	if(UseDLL(szUser32DLL) = 0) then
		if ( User32.GetKeyboardType( 0 ) = 7 ) then
    		if ( User32.GetKeyboardType( 1 ) > 3328 ) then
    			bRtnVal = TRUE;
        	endif;
    	endif;
    	UnUseDLL(szUser32DLL);
    endif;

    return bRtnVal;
end;

///////////////////////////////////////////////////////////////////////////////
//
//  Function: HandleMMC
//
//  Purpose: Checks to see if MMC is installed.  If it is NOT installed, we give
//			 the user the option to install it.  If it is installed, we check
//	       	 the version.  If it is an older version than the one we have, we
//			 install our version.  Otherwise we leave it alone.
//
//	Added 8/4/99 -- CMM
//
///////////////////////////////////////////////////////////////////////////////
function HandleMMC()
	BOOL bInstallMMC;
	STRING svVersionNumber;
begin
	bInstallMMC = FALSE;
	
	RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
    nvMMCInstalled = RegDBKeyExist(MICROSOFT_MANAGEMENT_CONSOLE);

    if(0 > nvMMCInstalled) then
    	// MMC is not installed, ask user if they want to install it
       	SetDialogTitle(DLG_ASK_YESNO, @TITLE_CAPTIONBAR);
    	if(AskYesNo(@ERROR_MMC_REQUIRED, YES) = YES) then
    		bInstallMMC = TRUE;
    	else
    		// No, exit the install
    		abort;
    	endif;
    else
    	// If the currently installed version number is earlier than ours or
    	// MMC does not exist, install it
    	if( VerGetFileVersion(WINSYSDIR ^ @FILE_MMC, svVersionNumber) < 0) then
           	bInstallMMC = TRUE;
    	else
	    	if ( LESS_THAN = VerCompare(svVersionNumber, @VERSION_MMC, VERSION) ) then
    	    	// Older version is installed, install MMC
        		bInstallMMC = TRUE;
    		endif;
    	endif;
    endif;

    if(bInstallMMC = TRUE) then
    	// Yes, install MMC
    	Enable(HOURGLASS);
    	SdShowMsg(@MSG_INSTALL_MMC, TRUE);
    	// Do the MMC installation
    	if(0 > LaunchAppAndWait(SUPPORTDIR ^ "immc.exe", "/Q", WAIT)) then
    		szTitle = @TITLE_CAPTIONBAR;
    		szMsg = @ERROR_INSTALL_MMC;
    		SprintfBox(SEVERE, szTitle, szMsg);
    		abort;
    	endif;
    	Disable(HOURGLASS);
    	SdShowMsg(@MSG_INSTALL_MMC, FALSE);
    endif;
end;

///////////////////////////////////////////////////////////////////////////////
//
//  Function: ModifyUninstallString
//
//  Purpose: Adds the -c command line switch to the uninstall string so that
//			 we will use our DLL to uninstall.
//
//	Added 8/17/99 -- CMM
//
///////////////////////////////////////////////////////////////////////////////
function ModifyUninstallString()
	STRING svUninstallString, szUninstallKey, szNewUninstallString;
	NUMBER nvType, nvSize;
begin
	szUninstallKey = "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall" ^ @UNINST_KEY;
	
	RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
	
	if(0 = RegDBGetKeyValueEx(szUninstallKey, "UninstallString", nvType, svUninstallString,
							  nvSize)) then
		szNewUninstallString = svUninstallString + " -c\"" + TARGETDIR ^ "QCInst.DLL\"";
		RegDBSetKeyValueEx(szUninstallKey, "UninstallString", REGDB_STRING,
						   szNewUninstallString, -1);
	endif;
end;

//////////////////////////////////////////////////////////////////////////
//
// Function:    CompareFileVersions
//
// Description:
//  Compares two file version strings (e.g., "4.72.3110.9") and returns a
//  number indicating if they are equal, or if not, which is older.
//
// Input:
//  szVer1, szVer2: The version strings to compare.
//
// Returns:
//  -1: szVer1 is older
//   0: versions are equal
//   1: szVer1 is newer
//
//////////////////////////////////////////////////////////////////////////

function CompareFileVersions ( szVer1, szVer2 )
    NUMBER nRet;
    NUMBER nDummy;
    LIST   lVer1;
    LIST   lVer2;
    STRING szNum1;
    STRING szNum2;
    NUMBER nNum1;
    NUMBER nNum2;
    BOOL   bDone;
begin
    nRet = 0;
    bDone = FALSE;

    lVer1 = ListCreate ( STRINGLIST );
    lVer2 = ListCreate ( STRINGLIST );

    if ( lVer1 = LIST_NULL || lVer2 = LIST_NULL )
    then
        return nRet;                    // nothing more we can do...
    endif;

    StrGetTokens ( lVer1, szVer1, "." );
    StrGetTokens ( lVer2, szVer2, "." );

    ListGetFirstString ( lVer1, szNum1 );
    ListGetFirstString ( lVer2, szNum2 );

    repeat
        StrToNum ( nNum1, szNum1 );
        StrToNum ( nNum2, szNum2 );

        if ( nNum1 > nNum2 )
        then
            nRet = 1;                   // szVer1 is newer
            bDone = TRUE;
        elseif ( nNum1 < nNum2 )
        then
            nRet = -1;
            bDone = TRUE;               // szVer2 is newer
        endif;

        if ( 0 != ListGetNextString ( lVer1, szNum1 ) ||
             0 != ListGetNextString ( lVer2, szNum2 ) )
        then
            bDone = TRUE;
        endif;
    until ( bDone );

    ListDestroy ( lVer1 );
    ListDestroy ( lVer2 );

    return nRet;
end;

///////////////////////////////////////////////////////////////////////////////
//
//  Function: QConsoleInstalled
//
//  Purpose: Returns TRUE if Quarantine Console is already installed.
//			 Added 9/13/99 -- CMM
//
///////////////////////////////////////////////////////////////////////////////
function QConsoleInstalled()
	NUMBER nvType, nvSize;
	STRING svValue;
begin
	RegDBSetDefaultRoot(HKEY_LOCAL_MACHINE);
	if(RegDBGetKeyValueEx(SYMANTEC_INSTALLED_APPS_KEY, @INSTAPP_VALUE, nvType, svValue,
						  nvSize)=0) then
		return TRUE;
	endif;
	
	return FALSE;
end;
// --- include script file section ---

#include "sddialog.rul"




